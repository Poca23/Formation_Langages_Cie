<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cours Spring Boot</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

</head>

<body>
    <nav>
        <div class="logo">
            <img src="https://raw.githubusercontent.com/spring-projects/spring-framework/main/framework-docs/src/docs/spring-framework.png"
                alt="Spring Logo" class="logo">
        </div>
        <button class="burger-menu" title="Menu">
            <i class="fas fa-bars"></i>
        </button>

        <ul class="nav-links">
            <li class="has-submenu">Cours
                <ul class="submenu">
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#composants">Les composants principaux</a></li>
                    <li><a href="#methodes">Les méthodes HTTP</a></li>
                    <li><a href="#bean">Les Beans</a></li>
                    <li><a href="#contraintes">Les contraintes de validation</a></li>
                    <li><a href="#cors">CORS (Cross Origin Ressources Sharing)</a></li>
                    <li><a href="#env-variables">Les variables d'environnement</a></li>
                    <li><a href="#auth-jwt">Mise en place de l'authentification - JWT</a></li>
                    <li><a href="#spring-security-intro">Introduction à Spring Security</a></li>
                    <li><a href="#pratique">Pratique</a></li>
                    <li><a href="#concepts">Concepts Clés</a></li>
                </ul>
            </li>
            <li><a href="#http-errors">Les codes d'État HTTP</a></li>
            <li><a href="#exercices">Exercices</a></li>
            <li><a href="#ressources">Ressources</a></li>
        </ul>
        <button id="themeToggle" title="Toggle Theme">
            <i class="fas fa-moon"></i>
        </button>
    </nav>

    <main class="container">
        <!--Introduction -->
        <section id="introduction" class="section">
            <h1>Spring Boot</h1>
            <div class="card" id="introCard">
                <h2>Qu'est-ce que Spring Boot ?</h2>
                <p>Spring Boot est un projet de la Spring Framework qui simplifie le processus de création
                    d'applications Spring.
                    Il permet aux développeurs de démarrer rapidement avec un minimum de configuration.</p>
                <ul class="features-list">
                    <li>Configuration automatique</li>
                    <li>Serveur embarqué</li>
                    <li>Métriques et monitoring</li>
                    <li>Production-ready</li>
                </ul>
                <button class="info-btn">En savoir plus</button>
            </div>

            <div class="card" id="prerequisCard">
                <h2>Prérequis</h2>
                <ul>
                    <li>Java 8 ou supérieur</li>
                    <li>Maven ou Gradle</li>
                    <li>Connaissances en Java</li>
                    <li>IDE (IntelliJ IDEA, Eclipse, VS Code)</li>
                </ul>
                <button class="info-btn">Détails des versions</button>
            </div>
        </section>


        <!-- Les composants principaux -->
        <section id="composants" class="section">
            <h2>Composants Principaux de Spring Boot</h2>

            <!-- Section Entités -->
            <div class="subsection">
                <h3>1. Les Entités (Entities)</h3>
                <div class="concept-card">
                    <i class="fas fa-database"></i>
                    <p>Les entités sont des classes Java qui représentent les tables de la base de données.</p>
                    <div class="code-section">
                        <pre><code>
        @Entity
        @Table(name = "users")
        public class User {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;
        
            @Column(nullable = false)
            private String username;
        
            @Column(nullable = false)
            private String email;
        
            // Getters et Setters
        }
                        </code></pre>
                    </div>
                    <ul class="features-list">
                        <li>@Entity : Marque la classe comme une entité JPA</li>
                        <li>@Table : Spécifie le nom de la table</li>
                        <li>@Id : Définit la clé primaire</li>
                        <li>@Column : Configure les propriétés de la colonne</li>
                    </ul>
                </div>
            </div>

            <!-- Section DAOs/Repositories -->
            <div class="subsection">
                <h3>2. Les DAOs/Repositories</h3>
                <div class="concept-card">
                    <i class="fas fa-layer-group"></i>
                    <p>Les repositories fournissent les méthodes d'accès aux données.</p>
                    <div class="code-section">
                        <pre><code>
        @Repository
        public interface UserRepository extends JpaRepository<User, Long> {
            Optional<User> findByEmail(String email);
            List<User> findByUsernameContaining(String username);
            boolean existsByEmail(String email);
        }
                        </code></pre>
                    </div>
                    <ul class="features-list">
                        <li>Héritage de JpaRepository pour les opérations CRUD</li>
                        <li>Méthodes personnalisées avec convention de nommage</li>
                        <li>Requêtes personnalisées avec @Query</li>
                    </ul>
                </div>
            </div>

            <!-- Section Controllers -->
            <div class="subsection">
                <h3>3. Les Controllers</h3>
                <div class="concept-card">
                    <i class="fas fa-server"></i>
                    <p>Les controllers gèrent les requêtes HTTP et définissent les endpoints de l'API.</p>
                    <div class="code-section">
                        <pre><code>
        @RestController
        @RequestMapping("/api/users")
        public class UserController {
            @Autowired
            private UserService userService;
        
            @GetMapping("/{id}")
            public ResponseEntity<User> getUser(@PathVariable Long id) {
                return userService.getUser(id)
                    .map(ResponseEntity::ok)
                    .orElse(ResponseEntity.notFound().build());
            }
        
            @PostMapping
            public ResponseEntity<User> createUser(@Valid @RequestBody User user) {
                return new ResponseEntity<>(userService.createUser(user), 
                    HttpStatus.CREATED);
            }
        }
                        </code></pre>
                    </div>
                    <ul class="features-list">
                        <li>@RestController combine @Controller et @ResponseBody</li>
                        <li>@RequestMapping définit le chemin de base</li>
                        <li>Annotations HTTP pour les méthodes</li>
                    </ul>
                </div>
            </div>

            <!-- Section Services -->
            <div class="subsection">
                <h3>4. Les Services</h3>
                <div class="concept-card">
                    <i class="fas fa-cogs"></i>
                    <p>Les services contiennent la logique métier de l'application.</p>
                    <div class="code-section">
                        <pre><code>
    @Service
    public class UserService {
        @Autowired
        private UserRepository userRepository;

        public User createUser(User user) {
            // Validation métier
            if (userRepository.existsByEmail(user.getEmail())) {
                throw new BusinessException("Email déjà utilisé");
            }
            
            // Logique métier
            user.setCreatedDate(LocalDateTime.now());
            return userRepository.save(user);
        }

        public Optional<User> getUser(Long id) {
            return userRepository.findById(id);
        }
    }
            </code></pre>
                    </div>
                    <ul class="features-list">
                        <li>@Service : Marque la classe comme un service Spring</li>
                        <li>Contient la logique métier</li>
                        <li>Orchestre les opérations entre Controllers et Repositories</li>
                        <li>Gère les transactions avec @Transactional</li>
                    </ul>
                </div>
            </div>

            <!-- Schéma Général Architecture -->
            <div class="subsection">
                <h3>Cycle Complet d'une Requête</h3>
                <div class="concept-card">
                    <i class="fas fa-exchange-alt"></i>
                    <div class="code-section">
                        <pre><code>
                                                    REQUEST                                                             RESPONSE
                    ┌──────────┐      ┌─────────────────────────────────────────────────────────────┐      ┌──────────┐
                    │          │ ───► │                     Spring Boot Application                  │ ───► │          │
                    │  Client  │      └─────────────────────────────────────────────────────────────┘      │  Client  │
                    │  (HTTP)  │          │              │              │               │                   │  (HTTP)  │
                    └──────────┘          ▼              ▼              ▼               ▼                   └──────────┘
                                    ┌──────────┐    ┌──────────┐   ┌──────────┐   ┌──────────┐                 ▲
                                    │Controller│    │ Service  │   │Repository│   │  Entity  │                 │
                                    │  (REST)  │───►│(Business)│──►│  (DAO)  │──►│  Model   │                 │
                                    └──────────┘    └──────────┘   └──────────┘   └──────────┘                 │
                                         │               │              │               │                        │
                                         │               │              │               │                        │
                                         │               │              ▼               │                        │
                                         │               │         ┌──────────┐         │                        │
                                         │               │         │Database  │         │                        │
                                         │               │         │  (SQL)   │         │                        │
                                         │               │         └──────────┘         │                        │
                                         │               │              ▲               │                        │
                                         │               │              │               │                        │
                                         │               └──────────────┘               │                        │
                                         └───────────────────────────────────────────────────────────────────────┘</code></pre>
                    </div>

                    <ul class="features-list">
                        <li>Client envoie requête HTTP (GET, POST, PUT, DELETE)</li>
                        <li>Controller reçoit la requête et valide les données</li>
                        <li>Service applique la logique métier</li>
                        <li>Repository prépare les opérations de base de données</li>
                        <li>Entity définit la structure des données</li>
                        <li>Database stocke/récupère les données</li>
                        <li>Les données remontent la chaîne</li>
                        <li>Service traite les données récupérées</li>
                        <li>Controller formate la réponse</li>
                        <li>Client reçoit la réponse HTTP</li>
                    </ul>

                    <div class="concept-card">
                        <h4>Détail des Responsabilités</h4>
                        <ul class="features-list">
                            <li><strong>Controller</strong>
                                <ul>
                                    <li>Gestion des endpoints REST</li>
                                    <li>Validation des requêtes</li>
                                    <li>Routage vers les services appropriés</li>
                                    <li>Formatage des réponses HTTP</li>
                                </ul>
                            </li>
                            <li><strong>Service</strong>
                                <ul>
                                    <li>Logique métier</li>
                                    <li>Transactions</li>
                                    <li>Orchestration des opérations</li>
                                    <li>Transformation des données</li>
                                </ul>
                            </li>
                            <li><strong>Repository</strong>
                                <ul>
                                    <li>Opérations CRUD</li>
                                    <li>Requêtes personnalisées</li>
                                    <li>Mapping Object-Relationnel</li>
                                </ul>
                            </li>
                            <li><strong>Entity</strong>
                                <ul>
                                    <li>Mapping avec la base de données</li>
                                    <li>Validation des données</li>
                                    <li>Relations entre entités</li>
                                </ul>
                            </li>
                        </ul>
                    </div>

                    <div class="concept-card">
                        <h4>Flux de Données Typique</h4>
                        <ul class="features-list">
                            <li>⬇️ Flux descendant (Request)
                                <ul>
                                    <li>Validation des données d'entrée</li>
                                    <li>Transformation en objets métier</li>
                                    <li>Persistance des données</li>
                                </ul>
                            </li>
                            <li>⬆️ Flux montant (Response)
                                <ul>
                                    <li>Récupération des données</li>
                                    <li>Transformation en DTOs</li>
                                    <li>Formatage de la réponse</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>


        <!-- Les méthodes HTTP -->
        <section id="methodes" class="section">
            <h2>Les Méthodes HTTP</h2>
            <!-- Section Méthodes HTTP -->
            <div class="subsection">
                <h3>5. Les Méthodes HTTP</h3>
                <div class="concept-card">
                    <i class="fas fa-exchange-alt"></i>

                    <!-- GET -->
                    <h4>GET</h4>
                    <div class="code-section">
                        <pre><code>
Client                    Serveur
   │        GET /users       │
   │─────────────────────►  │
   │                        │ [Lecture]
   │       [Données]        │
   │   [Status: 200 OK]     │
   │   [Error: 404 Not Found]│
   │◄─────────────────────  │
        </code></pre>
                    </div>
                    <p>Utilisé pour récupérer des données sans les modifier</p>

                    <!-- POST -->
                    <h4>POST</h4>
                    <div class="code-section">
                        <pre><code>
Client                    Serveur
   │    POST /users         │
   │   [Données]           │
   │─────────────────────► │
   │                       │ [Création]
   │    [Nouvel ID]        │
   │ [Status: 201 Created] │
   │ [Error: 400 Bad Request]│
   │◄─────────────────────-│
        </code></pre>
                    </div>
                    <p>Utilisé pour créer une nouvelle ressource</p>

                    <!-- PUT -->
                    <h4>PUT</h4>
                    <div class="code-section">
                        <pre><code>
Client                    Serveur
   │    PUT /users/1       │
   │   [Données]          │
   │─────────────────────►│
   │                      │ [Remplacement]
   │     [Status]         │
   │ [Status: 200 OK]     │
   │ [Error: 404 Not Found]│
   │◄────────────────────-│
        </code></pre>
                    </div>
                    <p>Utilisé pour mettre à jour complètement une ressource</p>

                    <!-- PATCH -->
                    <h4>PATCH</h4>
                    <div class="code-section">
                        <pre><code>
Client                    Serveur
   │   PATCH /users/1      │
   │  [Modifications]      │
   │─────────────────────►│
   │                      │ [Mise à jour]
   │     [Status]         │
   │ [Status: 200 OK]     │
   │ [Error: 404 Not Found]│
   │◄────────────────────-│
        </code></pre>
                    </div>
                    <p>Utilisé pour mettre à jour partiellement une ressource</p>

                    <!-- DELETE -->
                    <h4>DELETE</h4>
                    <div class="code-section">
                        <pre><code>
Client                    Serveur
   │  DELETE /users/1      │
   │─────────────────────►│
   │                      │ [Suppression]
   │     [Status]         │
   │[Status: 204 No Content]│
   │[Error: 404 Not Found] │
   │◄────────────────────-│
        </code></pre>
                    </div>
                    <p>Utilisé pour supprimer une ressource</p>

                    <ul class="features-list">
                        <li>GET : Lecture (idempotent)</li>
                        <li>POST : Création</li>
                        <li>PUT : Mise à jour complète (idempotent)</li>
                        <li>PATCH : Mise à jour partielle</li>
                        <li>DELETE : Suppression (idempotent)</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Les Beans -->
        <section id="bean" class="section">
            <div class="subsection">
                <h3>Les Beans, l'Injection de Dépendances et l'IoC</h3>
                <div class="concept-card">
                    <i class="fas fa-cogs"></i>

                    <h4>1. Qu'est-ce qu'un Bean ?</h4>
                    <p>Un Bean est simplement un objet Java qui est créé et géré par Spring. Imaginez-le comme une
                        brique de base de votre application.</p>
                    <div class="code-section">
                        <pre><code>
        // Un simple Bean Spring
        @Component  // Cette annotation dit à Spring "Ceci est un Bean"
        public class UserService {
            // Contenu de la classe
        }
                        </code></pre>
                    </div>

                    <h4>2. Le Conteneur IoC (Inversion of Control)</h4>
                    <div class="code-section">
                        <pre><code>
        ┌─────────────────────────────────────┐
        │         Spring IoC Container        │
        │                                     │
        │   ┌──────────┐      ┌──────────┐   │
        │   │ Bean 1   │      │ Bean 2   │   │
        │   └──────────┘      └──────────┘   │
        │                                     │
        │    Spring crée et gère les Beans    │
        └─────────────────────────────────────┘
                        </code></pre>
                    </div>
                    <p>Le conteneur IoC est comme une usine qui :</p>
                    <ul class="features-list">
                        <li>Crée les objets (Beans)</li>
                        <li>Les configure</li>
                        <li>Les assemble</li>
                        <li>Gère leur cycle de vie</li>
                    </ul>

                    <h4>3. L'Injection de Dépendances (DI)</h4>
                    <p>Au lieu de créer nos objets nous-mêmes, Spring les "injecte" là où nous en avons besoin.</p>

                    <h5>3.1 Sans Injection de Dépendances ❌</h5>
                    <div class="code-section">
                        <pre><code>
        public class UserService {
            // Création manuelle = Forte dépendance
            private UserRepository repository = new UserRepository();
        }
                        </code></pre>
                    </div>

                    <h5>3.2 Avec Injection de Dépendances ✅</h5>
                    <div class="code-section">
                        <pre><code>
        @Service
        public class UserService {
            private final UserRepository repository;
            
            // Spring injecte automatiquement UserRepository
            public UserService(UserRepository repository) {
                this.repository = repository;
            }
        }
                        </code></pre>
                    </div>

                    <h4>4. Les Différentes Façons d'Injecter</h4>
                    <div class="code-section">
                        <pre><code>
        ┌────────────────────────────────────┐
        │     Méthodes d'Injection          │
        │                                    │
        │ 1. Constructor ────► Recommandée   │
        │ 2. Setter     ────► Alternative    │
        │ 3. Field      ────► Déconseillée  │
        └────────────────────────────────────┘
        
        // 1. Constructor Injection (Recommandée)
        @Service
        public class UserService {
            private final UserRepository repository;
            
            public UserService(UserRepository repository) {
                this.repository = repository;
            }
        }
        
        // 2. Setter Injection
        @Service
        public class UserService {
            private UserRepository repository;
            
            @Autowired
            public void setRepository(UserRepository repository) {
                this.repository = repository;
            }
        }
        
        // 3. Field Injection (Éviter)
        @Service
        public class UserService {
            @Autowired
            private UserRepository repository;
        }
                        </code></pre>
                    </div>

                    <h4>5. Configuration des Beans</h4>
                    <p>Il existe deux façons principales de déclarer des Beans :</p>

                    <h5>5.1 Annotations (Méthode simple)</h5>
                    <div class="code-section">
                        <pre><code>
        @Component     // Pour les composants génériques
        @Service       // Pour la couche service
        @Repository    // Pour la couche d'accès aux données
        @Controller    // Pour les contrôleurs web
                        </code></pre>
                    </div>

                    <h5>5.2 Configuration Java (Plus de contrôle)</h5>
                    <div class="code-section">
                        <pre><code>
        @Configuration
        public class AppConfig {
            @Bean
            public UserService userService() {
                // Configuration personnalisée
                return new UserService(userRepository());
            }
        }
                        </code></pre>
                    </div>

                    <h4>6. Cycle de vie simplifié d'un Bean</h4>
                    <div class="code-section">
                        <pre><code>
        ┌─────────────────────────────────────┐
        │        Cycle de vie Bean            │
        │                                     │
        │ 1. Spring crée le Bean              │
        │          ↓                          │
        │ 2. Injection des dépendances        │
        │          ↓                          │
        │ 3. @PostConstruct                   │
        │          ↓                          │
        │ 4. Bean prêt à l'utilisation       │
        │          ↓                          │
        │ 5. @PreDestroy                      │
        │          ↓                          │
        │ 6. Bean détruit                     │
        └─────────────────────────────────────┘
                        </code></pre>
                    </div>

                    <h4>Points Clés à Retenir</h4>
                    <ul class="features-list">
                        <li>Les Beans sont des objets gérés par Spring</li>
                        <li>L'IoC nous libère de la création manuelle d'objets</li>
                        <li>L'injection de dépendances rend le code plus flexible</li>
                        <li>Préférez l'injection par constructeur</li>
                        <li>Utilisez @Component (ou ses variantes) pour les cas simples</li>
                        <li>Utilisez @Configuration/@Bean pour plus de contrôle</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Les Contraintes de Validation -->
        <section id="contraintes" class="section">
            <div class="subsection">
                <h3>Les Contraintes de Validation avec Spring Boot</h3>
                <div class="concept-card">
                    <i class="fas fa-check-circle"></i>

                    <h4>1. Introduction aux Validations</h4>
                    <p>Les contraintes de validation permettent de s'assurer que les données reçues par notre
                        application respectent certaines règles avant d'être traitées.</p>

                    <h4>2. Mise en Place des Validations</h4>
                    <p>Tout d'abord, ajoutez la dépendance dans votre pom.xml :</p>
                    <div class="code-section">
                        <pre><code>
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
    &lt;/dependency&gt;
                </code></pre>
                    </div>

                    <h4>3. Les Annotations de Validation Courantes</h4>
                    <div class="code-section">
                        <pre><code>
@NotNull          : La valeur ne doit pas être null
@NotEmpty         : La chaîne/collection ne doit pas être vide
@NotBlank         : La chaîne ne doit pas être vide ou constituée uniquement d'espaces
@Min(value)       : Valeur minimale pour les nombres
@Max(value)       : Valeur maximale pour les nombres
@Size             : Taille d'une chaîne, collection, tableau
@Email            : Format d'email valide
@Pattern          : Expression régulière à respecter
@URL              : Format d'URL valide
@Positive         : Valeur numérique strictement positive
@Negative         : Valeur numérique strictement négative
@PositiveOrZero   : Valeur numérique positive ou nulle
@NegativeOrZero   : Valeur numérique négative ou nulle
@Past             : Date dans le passé
@Future           : Date dans le futur
@PastOrPresent    : Date dans le passé ou présent
@FutureOrPresent  : Date dans le futur ou présent
@Valid            : Validation en cascade des objets imbriqués
                        </code></pre>
                    </div>

                    <h4>3.1 Placement des Contraintes de Validation</h4>
                    <div class="code-section">
                        <pre><code>
                    public class User {
                        // 1️⃣ Sur l'attribut : Validation directe de la donnée
                        @NotNull
                        private String name;
                    
                        // 2️⃣ Sur le getter : Validation après transformation
                        private String email;
                        
                        @Email
                        public String getEmail() {
                            return email.toLowerCase(); // Validation après transformation
                        }
                    }
                        </code></pre>
                    </div>

                    <p>Le placement des contraintes dépend du moment souhaité pour la validation :</p>
                    <ul class="features-list">
                        <li><strong>Sur l'attribut</strong> : Pour une validation immédiate de la donnée brute</li>
                        <li><strong>Sur le getter</strong> : Pour valider après une éventuelle transformation de la
                            donnée</li>
                    </ul>


                    <h4>4. Exemple Pratique</h4>
                    <p>Créons une classe User avec des validations :</p>
                    <div class="code-section">
                        <pre><code>
    import javax.validation.constraints.*;

    public class User {
        @NotNull(message = "L'id ne peut pas être null")
        private Long id;

        @NotBlank(message = "Le nom est obligatoire")
        @Size(min = 2, max = 50, message = "Le nom doit faire entre 2 et 50 caractères")
        private String name;

        @Email(message = "Format d'email invalide")
        private String email;

        @Min(value = 18, message = "L'âge minimum est 18 ans")
        private int age;
    }
                </code></pre>
                    </div>

                    <h4>5. Validation dans le Controller</h4>
                    <div class="code-section">
                        <pre><code>
    @RestController
    @RequestMapping("/api/users")
    public class UserController {

        @PostMapping
        public ResponseEntity&lt;User&gt; createUser(@Valid @RequestBody User user) {
            // Si la validation échoue, Spring retourne automatiquement 
            // une erreur 400 Bad Request
            return ResponseEntity.ok(userService.save(user));
        }
    }
                </code></pre>
                    </div>

                    <h4>5.1 Utilisation Complète de @Valid dans le Controller</h4>
                    <p>L'annotation @Valid doit être placée systématiquement avant @RequestBody pour toutes les
                        opérations
                        modifiant des données :</p>
                    <div class="code-section">
                        <pre><code>
                    @RestController
                    @RequestMapping("/api/products")
                    public class ProductController {
                    
                        @PostMapping  // Création
                        public ResponseEntity&lt;Product&gt; createProduct(@Valid @RequestBody Product product) {
                            return ResponseEntity.status(HttpStatus.CREATED).body(productService.save(product));
                        }
                    
                        @PutMapping("/{id}")  // Mise à jour complète
                        public ResponseEntity&lt;Product&gt; updateProduct(
                            @PathVariable Long id, 
                            @Valid @RequestBody Product product) {
                            return ResponseEntity.ok(productService.update(id, product));
                        }
                    
                        @PatchMapping("/{id}")  // Mise à jour partielle
                        public ResponseEntity&lt;Product&gt; partialUpdateProduct(
                            @PathVariable Long id, 
                            @Valid @RequestBody Product product) {
                            return ResponseEntity.ok(productService.partialUpdate(id, product));
                        }
                    }
                        </code></pre>
                    </div>

                    <ul class="features-list">
                        <li>@Valid est nécessaire pour toute opération recevant des données (POST, PUT, PATCH)</li>
                        <li>Se place toujours avant @RequestBody</li>
                        <li>Non nécessaire pour les opérations de lecture (GET) ou suppression (DELETE)</li>
                        <li>Garantit la validation des données avant tout traitement</li>
                    </ul>


                    <h4>6. Gestion Personnalisée des Erreurs</h4>
                    <div class="code-section">
                        <pre><code>
    @ControllerAdvice
    public class ValidationExceptionHandler {

        @ExceptionHandler(MethodArgumentNotValidException.class)
        public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(
            MethodArgumentNotValidException ex) {
            
            Map&lt;String, String&gt; errors = new HashMap<>();
            
            ex.getBindingResult().getAllErrors().forEach(error -> {
                String fieldName = ((FieldError) error).getField();
                String errorMessage = error.getDefaultMessage();
                errors.put(fieldName, errorMessage);
            });
            
            return ResponseEntity.badRequest().body(errors);
        }
    }
                </code></pre>
                    </div>

                    <h4>7. Exemple de Validation Personnalisée</h4>
                    <p>Création d'une annotation personnalisée :</p>
                    <div class="code-section">
                        <pre><code>
    // L'annotation
    @Target({ElementType.FIELD})
    @Retention(RetentionPolicy.RUNTIME)
    @Constraint(validatedBy = PasswordValidator.class)
    public @interface StrongPassword {
        String message() default "Mot de passe trop faible";
        Class<?>[] groups() default {};
        Class<? extends Payload>[] payload() default {};
    }

    // Le validateur
    public class PasswordValidator implements ConstraintValidator&lt;StrongPassword, String&gt; {
        @Override
        public boolean isValid(String value, ConstraintValidatorContext context) {
            return value != null && 
                   value.length() >= 8 && 
                   value.matches(".*[A-Z].*") && 
                   value.matches(".*[a-z].*") && 
                   value.matches(".*[0-9].*");
        }
    }

    // Utilisation
    public class User {
        @StrongPassword
        private String password;
    }
                </code></pre>
                    </div>

                    <h4>Points Clés à Retenir</h4>
                    <ul class="features-list">
                        <li>Les validations permettent de vérifier les données avant traitement</li>
                        <li>@Valid active la validation sur un objet</li>
                        <li>Les messages d'erreur peuvent être personnalisés</li>
                        <li>Possibilité de créer des validations personnalisées</li>
                        <li>Spring gère automatiquement les erreurs de validation</li>
                        <li>Les validations améliorent la robustesse de l'application</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- CORS et Communication React-Spring -->
        <section id="cors" class="section">
            <div class="subsection">
                <h3>Intégration React et Spring Boot : Configuration et Tests avec CORS</h3>
                <div class="concept-card">
                    <i class="fas fa-code-branch"></i>

                    <h4>1. Contexte et Objectif</h4>
                    <p>Dans un projet moderne, le backend (avec Spring Boot) et le frontend (avec React) doivent
                        fonctionner ensemble. Mais par défaut, ils ne peuvent pas communiquer librement s'ils sont
                        exécutés sur des serveurs ayant des origines différentes (par exemple, backend sur
                        <code>http://localhost:8080</code> et frontend sur <code>http://localhost:3000</code>). C'est
                        ici que le <b>CORS</b> (Cross-Origin Resource Sharing) entre en jeu.
                    </p>

                    <h4>2. Qu’est-ce que CORS ?</h4>
                    <p>
                        CORS est une *politique de sécurité* utilisée par les navigateurs pour empêcher des requêtes
                        provenant d'une origine non autorisée. Avec CORS correctement configuré, le backend autorisera
                        React à lui envoyer des requêtes.
                    </p>

                    <div class="code-section schema">
                        <pre>
                  ┌───────────────┐       Requête API        ┌───────────────┐
                  │ Frontend React│ ───────────────────────► │ Backend Spring│
                  │http://localhost:3000 │                │http://localhost:8080│
                  └───────────────┘       Réponse API       └───────────────┘
                            🚫<b>Sans configuration CORS :</b> Erreur bloquée par le navigateur.
                            ✅<b>Avec configuration CORS :</b> Communication réussie.
                  </pre>
                    </div>

                    <h4>3. Mise en Place de la Communication</h4>
                    <p>Voici comment configurer CORS et connecter les deux applications de manière fluide.</p>

                    <h5>Étape 1 : Créer un Backend Spring Boot</h5>
                    <p>Créez un projet Spring Boot avec une simple API REST. Par exemple :</p>
                    <div class="code-section">
                        <pre><code>
          @RestController
          @RequestMapping("/api")
          public class TestController {
              @GetMapping("/test")
              public String test() {
                  return "Hello depuis Spring Boot !";
              }
          }
                  </code></pre>
                    </div>

                    <h5>Étape 2 : Configurer CORS dans Spring Boot</h5>
                    <p>Ajoutez une configuration CORS pour permettre à React d’accéder au backend :</p>
                    <div class="code-section">
                        <pre><code>
          @Configuration
          public class CorsConfig implements WebMvcConfigurer {
              @Override
              public void addCorsMappings(CorsRegistry registry) {
                  registry.addMapping("/**") // Appliquer à tous les endpoints
                          .allowedOrigins("http://localhost:3000") // Autorise React
                          .allowedMethods("GET", "POST", "PUT", "DELETE");
              }
          }
                  </code></pre>
                    </div>

                    <h5>Étape 3 : Créer un Frontend React</h5>
                    <p>Créez un composant React pour tester l'appel au backend :</p>
                    <div class="code-section">
                        <pre><code>
          import React, { useEffect, useState } from 'react';
          
          const TestComponent = () => {
              const [data, setData] = useState("");
          
              useEffect(() => {
                  fetch("http://localhost:8080/api/test")
                      .then(response => response.text())
                      .then(data => setData(data))
                      .catch(error => console.error("Erreur :", error));
              }, []);
          
              return (
                  <div>
                      <h1>Test API</h1>
                      <p>Réponse du backend : {data}</p>
                  </div>
              );
          };
          
          export default TestComponent;
                  </code></pre>
                    </div>

                    <h5>Étape 4 : Tester la Communication</h5>
                    <p>1. Lancez le backend Spring Boot sur le port 8080.
                        2. Lancez le frontend React sur le port 3000.
                        3. Accédez au composant React et vérifiez que la réponse du backend s'affiche correctement.</p>

                    <div class="code-section schema">
                        <pre>
                  🌐 Frontend React       🔄        Backend Spring Boot
                  ┌─────────────────────────────────────────────┐
                  │1. Appel fetch() depuis React                │
                  │   URL : http://localhost:8080/api/test      │
                  └─────────────────────────────────────────────┘
                              ⬆ CORS configuré ⬇
                  ┌─────────────────────────────────────────────┐
                  │2. Réponse JSON ou String : "Hello depuis…"  │
                  └─────────────────────────────────────────────┘
                  </pre>
                    </div>

                    <h4>4. Résoudre les Problèmes Courants</h4>
                    <div class="features-list">
                        <li><b>Erreur CORS :</b> Vérifiez que l'origine utilisée dans Spring Boot correspond à celle du
                            frontend.</li>
                        <li><b>Backend inaccessible :</b> Assurez-vous que le backend tourne bien à l'adresse
                            <code>http://localhost:8080</code>.
                        </li>
                        <li><b>Pas de réponse :</b> Vérifiez que votre URL dans React est correcte.</li>
                    </div>

                    <h4>5. Bonnes Pratiques</h4>
                    <ul class="features-list">
                        <li>Utilisez un composant test (comme notre `TestController`) pour isoler les problèmes.</li>
                        <li>Configurez CORS globalement dans Spring Boot pour un développement fluide.</li>
                        <li>Gardez les tests React pour vérifier rapidement la connectivité lors de modifications.</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Les variables d'environnement -->
        <section id="env-variables" class="section">
            <div class="subsection">
                <h3>Les Variables d’Environnement</h3>
                <div class="concept-card">
                    <i class="fas fa-lock"></i>

                    <h4>1. Introduction</h4>
                    <p>Souviens-toi, dans ton fichier <code>application.properties</code>, tu as peut-être défini des
                        informations telles que :</p>
                    <div class="code-section">
                        <pre><code>
          spring.datasource.url=jdbc:mysql://localhost:3306/visiotech_db?createDatabaseIfNotExist=true
          spring.datasource.username=your_mysql_username # 👈 à remplacer
          spring.datasource.password=your_mysql_password # 👈 à remplacer
                  </code></pre>
                    </div>
                    <p>Le problème, c'est que ces informations sont **sensibles**. Tu ne veux pas qu'elles soient
                        visibles par tout le monde, surtout si ton code est versionné sur GitHub.</p>
                    <p>Pour résoudre ce problème, tu peux utiliser des **variables d’environnement**, un outil puissant
                        pour sécuriser et structurer les configurations de ton application. 🌟</p>

                    <div class="schema">
                        <pre>
          💻 Ton application        🔒 Variables d'environnement
                 ↓                               ↓
              Utilise les valeurs      Stocke les infos sensibles
                    lors de                 dans un système
              l'exécution.              sécurisé et externe.
                  </pre>
                    </div>

                    <h4>2. Pourquoi utiliser des Variables d’Environnement ?</h4>
                    <ul class="features-list">
                        <li><b>🔒 Sécurité :</b> Les informations comme les mots de passe sont stockées en dehors du
                            code source, évitant ainsi tout partage accidentel.</li>
                        <li><b>🚀 Portabilité :</b> Change les configurations en fonction des différentes étapes du
                            projet (développement, test, production).</li>
                        <li><b>⚙️ Facilité d’utilisation :</b> Modifie les paramètres sans toucher au code ou aux
                            fichiers versionnés.</li>
                    </ul>

                    <h4>3. Mise en Place avec Spring Boot et spring-dotenv</h4>
                    <p>Voyons comment implémenter des variables d’environnement dans un projet Spring Boot de manière
                        sécurisée et propre. 🛠️</p>

                    <h5>3.1 Ajoute la Dépendance Maven</h5>
                    <p>Tout commence par l’ajout de la dépendance suivante dans <code>pom.xml</code> :</p>
                    <div class="code-section">
                        <pre><code>
          <dependency>
              <groupId>me.paulschwarz</groupId>
              <artifactId>spring-dotenv</artifactId>
              <version>3.0.0</version>
          </dependency>
                  </code></pre>
                    </div>
                    <p><b>💡 Tip :</b> Après avoir modifié ton <code>pom.xml</code>, n’oublie pas de <b>refresh</b> ton
                        projet Maven !</p>

                    <h5>3.2 Crée le Fichier <code>.env</code></h5>
                    <p>Ajoute un fichier <code>.env</code> à la racine de ton projet (au même niveau que le dossier
                        <code>src</code>) et configure-y tes infos sensibles :
                    </p>
                    <div class="code-section">
                        <pre><code>
          DB_URL=jdbc:mysql://localhost:3306/visiotech_db?createDatabaseIfNotExist=true
          DB_USERNAME=your_mysql_username
          DB_PASSWORD=your_mysql_password
                  </code></pre>
                    </div>
                    <p>Voici où placer le fichier :</p>
                    <div class="schema">
                        <pre>
          🔖 Mon Projet Spring Boot
          ├── src/
          ├── pom.xml
          └── .env  👈 Ajoute ton fichier ici
                  </pre>
                    </div>

                    <h5>3.3 Ignore le Fichier <code>.env</code> dans Git</h5>
                    <p>Ajoute <code>.env</code> à ton fichier <code>.gitignore</code> pour t'assurer qu'il ne soit
                        jamais versionné :</p>
                    <div class="code-section">
                        <pre><code>
          # Ignorer les fichiers contenant des variables sensibles
          .env
                  </code></pre>
                    </div>
                    <p><b>⚠️ ATTENTION :</b> Ne partage jamais ce fichier, car il contient des informations sensibles.
                    </p>

                    <h5>3.4 Ajoute un fichier <code>.envsample</code></h5>
                    <p>Crée un fichier <code>.envsample</code> pour partager avec d’autres développeurs un
                        <i>template</i> indiquant les variables nécessaires, sans leurs valeurs :
                    </p>
                    <div class="code-section">
                        <pre><code>
          DB_URL=
          DB_USERNAME=
          DB_PASSWORD=
                  </code></pre>
                    </div>
                    <p>Ainsi, chaque développeur peut copier ce fichier, le renommer en <code>.env</code> et remplir les
                        valeurs selon ses besoins.</p>

                    <h5>3.5 Remplace les Configurations dans <code>application.properties</code></h5>
                    <p>Édite le fichier <code>application.properties</code> pour référencer tes variables
                        d’environnement. Utilise la syntaxe <code>${VAR_NAME}</code>, comme ceci :</p>
                    <div class="code-section">
                        <pre><code>
          spring.datasource.url=${DB_URL}
          spring.datasource.username=${DB_USERNAME}
          spring.datasource.password=${DB_PASSWORD}
          spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
          
          spring.sql.init.mode=always
          logging.level.org.springframework.jdbc.core=DEBUG
                  </code></pre>
                    </div>
                    <p>Lorsque tu démarres l’application, les valeurs de <code>.env</code> sont automatiquement
                        injectées. 🚀</p>

                    <h4>4. Schéma de Fonctionnement</h4>
                    <div class="schema">
                        <pre>
          🌐 Ton application Spring Boot
                 ↕
          📄 application.properties ▶ Référence les variables d’environnement
                 ↕
          📂 .env ▶ Contient les valeurs sensibles (non partagé)
                  </pre>
                    </div>

                    <h4>5. Bonnes Pratiques</h4>
                    <ul class="features-list">
                        <li>Ajoute <code>.env</code> à <code>.gitignore</code>.</li>
                        <li>Crée un <code>.envsample</code> pour guider tes collègues.</li>
                        <li>Ne jamais mettre de valeurs sensibles directement dans <code>application.properties</code>.
                        </li>
                        <li>Utilise des outils comme <b>Vault</b> ou <b>Secrets Manager</b> si ton application est en
                            production.</li>
                    </ul>

                    <h4>6. Ce que tu as appris</h4>
                    <ul class="features-list">
                        <li>Comprendre la valeur et l’usage des variables d’environnement.</li>
                        <li>Configurer un fichier <code>.env</code> dans un projet Spring Boot avec la librairie
                            <code>spring-dotenv</code>.
                        </li>
                        <li>Éviter de partager des données sensibles dans Git.</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Mise en place de l'authentification -->
        <section id="auth-jwt" class="section">
            <div class="subsection">
                <h2>Mise en Place de l’Authentification</h2>
                <p>🚀 Dans ce chapitre, tu vas apprendre à utiliser les **JWT (JSON Web Tokens)** pour mettre en place
                    un système d’authentification sécurisé dans ton application. Ils permettront de restreindre l’accès
                    aux endpoints de ton API en fonction des rôles d’utilisateur.</p>

                <h3>📚 Objectifs</h3>
                <ul>
                    <li>✅ Différencier authentification et autorisation</li>
                    <li>✅ Comprendre comment un JWT facilite l’authentification</li>
                    <li>✅ Visualiser le séquençage d’une authentification</li>
                    <li>✅ Être capable de comprendre et structurer un JWT</li>
                </ul>
            </div>

            <div class="subsection">
                <h3>Authentification VS Autorisation</h3>
                <p>La première chose est de bien faire la différence entre **authentification** et **autorisation** :
                </p>

                <div class="concept-card">
                    <h4>🔑 Authentification</h4>
                    <ul>
                        <li><strong>Objectif :</strong> Vérifie l’identité de l’utilisateur.</li>
                        <li><strong>Exemple :</strong> L’utilisateur fournit un email + mot de passe pour prouver son
                            identité (login).</li>
                    </ul>
                </div>

                <div class="concept-card">
                    <h4>🚦 Autorisation</h4>
                    <ul>
                        <li><strong>Objectif :</strong> Vérifie ce que l’utilisateur a le droit de faire.</li>
                        <li><strong>Exemple :</strong> Un utilisateur connecté avec un rôle `ADMIN` peut modifier
                            d’autres utilisateurs, mais un `USER` ne peut que visualiser son propre profil.</li>
                    </ul>
                </div>

                <div class="schema">
                    <h5>🖼️ Résumé visuel</h5>
                    <pre>
          1️⃣ AUTHENTIFICATION :
          
          🔑 Utilisateur :
             ➡️ Email : user@example.com
             ➡️ Mot de passe : password123
          
          Serveur : ✔ Authentification réussie, voici ton <token> !
          
          ---
          
          2️⃣ AUTORISATION
          🛂 Avec le token :
          
            🔓 Accès autorisé (rôle : ADMIN)
            🔒 Accès refusé (pas le bon rôle)
                </pre>
                </div>
            </div>

            <div class="subsection">
                <h3>Le Workflow : Comment fonctionne l’authentification JWT ?</h3>
                <p>Pour illustrer le process complet d’authentification avec JWT, voici un schéma basé sur un cas
                    classique :</p>

                <div class="schema">
                    <h5>🗺️ Étapes d’authentification avec JWT</h5>
                    <pre>
          1️⃣ Création de Compte :
          Utilisateur ➡️ /auth/register ➡️ Serveur ➡️ Sauvegarde dans BDD 🗄️
          
          2️⃣ Login :
          Utilisateur ➡️ /auth/login ➡️ Génération d’un JWT 🔑
                                  Serveur valide ou refuse les identifiants.
          
          3️⃣ Utilisation d’un Token pour Réquêtes API :
          Client ➡️ HTTP Header (Authorization: Bearer <JWT>)
          Serveur                    ↕ Valide et Autorise/Refuse.
                </pre>
                </div>
            </div>

            <div class="subsection">
                <h3>Qu’est-ce qu’un JWT (JSON Web Token) ?</h3>
                <p>Un **JWT** est une clé sécurisée, utilisée comme preuve d’identité. Elle se compose de 3 parties :
                </p>

                <ul class="features-list">
                    <li><b>📍 Header :</b> Contient des informations sur l’algorithme et le type de token (JWT).</li>
                    <li><b>📦 Payload :</b> Transporte des informations sur l’utilisateur (email, rôle, etc.)</li>
                    <li><b>🖋️ Signature :</b> Vérifie l'intégrité du token pour s’assurer qu’il n’a pas été modifié.
                    </li>
                </ul>

                <div class="code-section">
                    <h5>🔗 Exemple d’un JWT</h5>
                    <pre><code>
          eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
          .eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
          .SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
                </code></pre>
                </div>

                <div class="concept-card">
                    <h4>Structure</h4>
                    <ul>
                        <li><strong>Header</strong> :<br>{ "alg": "HS256", "typ": "JWT" }</li>
                        <li><strong>Payload</strong> :<br>{ "email": "user@example.com", "role": "USER", "exp":
                            1697801937 }</li>
                        <li><strong>Signature</strong> : (signée avec une clé secrète).</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <h3>Résumé des Étapes : Authentification par JWT</h3>
                <div class="schema">
                    <pre>
          1️⃣ Authentification auprès du serveur :
             Utilisateur 👉 `/auth/login` (email + mot de passe)
             Serveur valide et génère un JWT.
          
          2️⃣ Requête API sécurisée :
             Client 👉 envoie le Header HTTP: Authorization: Bearer <TOKEN>
             Serveur valide le token reçu 📑.
          
          3️⃣ Expiration :
             Si le token expire, utilisateur doit se reconnecter.
                </pre>
                </div>
                <p>🔥 Et voilà ! Tu sais maintenant comment fonctionne une authentification sécurisée par JWT. 🛡️ On te
                    montre comment l’implémenter dans les chapitres suivants.</p>
                <div class="challenge-card">
                    <h4>🚀 Challenge !</h4>
                    <p>Reproduis ce workflow dans ton projet :</p>
                    <ol>
                        <li>Crée un endpoint `/auth/register` pour enregistrer les utilisateurs.</li>
                        <li>Crée un endpoint `/auth/login` qui génère un JWT après validation.</li>
                        <li>Configure un filtre JWT pour gérer l'autorisation sur tes routes sécurisées.</li>
                    </ol>
                </div>
            </div>
        </section>


        <!-- Introduction à Spring Security -->
        <section id="spring-security-intro" class="section">
            <div class="subsection">
                <h2>Introduction à Spring Security 🚀</h2>
                <p>🎯 **Spring Security** est une bibliothèque de Spring qui fournit une couche de sécurité pour gérer :
                    l’authentification, les autorisations, la protection des routes et bien plus encore.</p>
                <p>Dans ces prochaines étapes, tu vas apprendre comment mettre en place l’**authentification par JWT
                    Header** avec Spring Security, tout en découvrant ses concepts essentiels.</p>
            </div>

            <div class="subsection">
                <h3>🛡️ Spring Security en quelques mots</h3>
                <p>C’est une **solution de sécurité robuste**, souvent utilisée dans les applications Java/Spring pour
                    sécuriser les APIs et contrôler les accès. Voici ce qu’il faut retenir avant d’approfondir plus loin
                    :</p>

                <ul class="features-list">
                    <li>✅ <strong>Dépendance Maven</strong> : s’active avec un ajout dans le `pom.xml`.</li>
                    <li>✅ <strong>Gestion des CORS</strong> : intégrée directement.</li>
                    <li>✅ <strong>Configuration flexible</strong> : permet de définir quelles routes sont protégées ou
                        publiques.</li>
                    <li>✅ <strong>Contrôle par rôle</strong> : restreint l’accès aux routes selon les rôles (ex.
                        `ADMIN`, `USER`).</li>
                    <li>✅ <strong>Couche en amont</strong> : Spring Security agit avant même que les requêtes
                        n’atteignent les contrôleurs.</li>
                    <li>✅ <strong>Sécurisé par défaut</strong> : toute requête sur une route non définie renvoie un
                        statut **403 : Forbidden**.</li>
                </ul>

                <div class="notification">
                    🔗 Tu peux explorer la <a href="https://docs.spring.io/spring-security/reference/index.html" rel="noopener"
                        target="_blank">documentation officielle ici</a>.
                </div>
            </div>

            <div class="subsection">
                <h3>🗺️ Schéma global : Pourquoi utiliser Spring Security ?</h3>
                <p>Voici un aperçu clair de la manière dont Spring Security s’intègre dans ton application :</p>

                <div class="schema">
                    <h5>✨ Architecture simplifiée</h5>
                    <pre>
                                          🛡️ SPRING SECURITY
           --------------------------------------------------------------------
          |                                                                    |
          |      ➡️ Requête Entrante                                           |
          |                                                                    |
          |      🔍 Analyse et Filtrage (CORS, Authentification)               |
          |      🔓 Validation des Roles                                       |
          |                                                                    |
           --------------------------------------------------------------------
                  ⬇️                                                                  ⬇️
                [Bloqué : 403 ❌]                                  [Requête Acceptée : OK ✅]
                                      ⬇️ Contrôleurs
                            (Code métier atteint uniquement si autorisé)
                </pre>
                    <p>💡 **En résumé :** Spring Security agit comme un filtre qui protège ton application en bloquant
                        les requêtes non authentifiées ou non autorisées avant qu'elles ne parviennent à tes
                        contrôleurs.</p>
                </div>
            </div>

            <div class="subsection">
                <h3>⚙️ Comment configurer Spring Security ?</h3>
                <p>Pour mettre en place l’authentification par **JWT avec Spring Security**, voici les étapes globales
                    que tu seras amené(e) à suivre :</p>

                <ol class="steps-list">
                    <li><strong>📂 Base de données :</strong> Crée les tables nécessaires pour gérer les utilisateurs.
                    </li>
                    <li><strong>🧩 Entités :</strong> Crée deux entités (par exemple : `User` et `Role`).</li>
                    <li><strong>💾 DAO :</strong> Crée un `UserDao` pour accéder aux données.</li>
                    <li><strong>🛠️ Service :</strong> Implémente un service personnalisé pour gérer les utilisateurs.
                    </li>
                    <li><strong>🔑 JWT :</strong> Développe un utilitaire pour générer et valider les tokens JWT.</li>
                    <li><strong>🔍 Filtre JWT :</strong> Ajoute un filtre pour intercepter et valider les requêtes
                        entrantes.</li>
                    <li><strong>📜 Configuration :</strong> Définit les routes protégées ou non protégées.</li>
                    <li><strong>📡 Contrôleur :</strong> Crée un contrôleur avec des endpoints comme `/register` et
                        `/login`.</li>
                </ol>

                <div class="diagram">
                    <img src="images/spring_security_workflow.png" alt="Spring Security Workflow"
                        class="responsive-image">
                    <p>Ce diagramme montre comment les composants se connectent et interagissent grâce à Spring
                        Security.</p>
                </div>
            </div>

            <div class="subsection">
                <h3>⚖️ Pourquoi et quand utiliser Spring Security ?</h3>
                <p>Voici une liste critique pour savoir **quand choisir Spring Security** :</p>

                <ul class="pros-and-cons">
                    <li><strong>Utiliser Spring Security si :</strong>
                        <ul>
                            <li>✅ Tu cherches une solution complète de gestion de l’authentification (login/logout).
                            </li>
                            <li>✅ Tu dois contrôler les accès (par rôle ou permissions).</li>
                            <li>✅ Tu utilises déjà l’écosystème Spring Boot.</li>
                            <li>✅ Tu souhaites sécuriser ton application via des JWT ou Basic Auth.</li>
                        </ul>
                    </li>
                    <li><strong>Ne pas utiliser Spring Security si :</strong>
                        <ul>
                            <li>❌ Ton projet est très léger (et n'utilise pas Spring Boot).</li>
                            <li>❌ Tu recherches une solution très simplifiée sans authentification avancée.</li>
                        </ul>
                    </li>
                </ul>

                <p><strong>En résumé :</strong> Spring Security est idéal lorsqu’un haut degré de sécurité et de
                    personnalisation est requis, notamment dans des environnements professionnels ou complexes.</p>
            </div>

            <div class="subsection">
                <h3>🎯 Étape suivante : Implémentation complète</h3>
                <p>Dans les chapitres suivants, tu apprendras à implémenter chaque étape, petit à petit :</p>

                <div class="next-steps-list">
                    <ul>
                        <li>👨‍💻 [Base de données, entités et DAO](#)</li>
                        <li>🔐 [Création du service utilisateur](#)</li>
                        <li>🔑 [Génération et validation du JWT](#)</li>
                        <li>⚙️ [Ajout d’un filtre JWT dynamique](#)</li>
                        <li>🛡️ [Configuration des routes sécurisées](#)</li>
                        <li>📡 [Endpoints /register et /login](#)</li>
                    </ul>
                </div>
                <p><a href="#next-chapter" class="button">➡️ Passer au chapitre suivant</a></p>
            </div>
        </section>


        <!-- Pratique -->
        <section id="pratique" class="section">
            <div class="concept-card">
                <div class="subsection">
                    <h2>Mise en Pratique</h2>

                    <div class="subsection">
                        <h3>1. Création d'un projet</h3>
                        <div class="concept-card">
                            <div class="code-example">
                                <pre><code>
<!-- Utilisation de Spring Initializr -->
https://start.spring.io/
- Choisir Maven/Gradle
- Choisir Java 8+
- Ajouter les dépendances:
  * Spring Web
  * Spring Data JPA
  * H2 Database
            </code></pre>
                                <button class="copy-btn">Copier</button>
                            </div>
                        </div>
                    </div>


                    <div class="subsection">
                        <h3>2. Structure du projet</h3>
                        <div class="concept-card">
                            <div class="code-example">
                                <pre><code>
projet-demo/
    ├── src/
    │   ├── main/
    │   │   ├── java/
    │   │   │   └── com/example/demo/
    │   │   │       ├── DemoApplication.java
    │   │   │       ├── controllers/
    │   │   │       ├── models/
    │   │   │       ├── repositories/
    │   │   │       └── services/
    │   │   └── resources/
    │   │       └── application.properties
    │   └── test/
    └── pom.xml
            </code></pre>
                                <button class="copy-btn">Copier</button>
                            </div>
                        </div>
                    </div>


                    <div class="subsection">
                        <h3>3. Application Simple</h3>
                        <div class="concept-card">
                            <div class="code-example">
                                <pre><code>
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}

@RestController
@RequestMapping("/api")
public class HelloController {
    @GetMapping("/hello")
    public String hello() {
        return "Hello Spring Boot!";
    }
}
            </code></pre>
                                <button class="copy-btn">Copier</button>
                            </div>
                        </div>
                    </div>


                    <div class="subsection">
                        <h3>4. Configuration</h3>
                        <div class="concept-card">
                            <div class="code-example">
                                <pre><code>
# application.properties
server.port=8080
spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
            </code></pre>
                                <button class="copy-btn">Copier</button>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </section>


        <!-- Concepts -->
        <section id="concepts" class="section">
            <h2>Concepts Clés</h2>
            <div class="concepts-grid">
                <div class="concept-card">
                    <i class="fas fa-cogs"></i>
                    <h3>Auto-configuration</h3>
                    <p>Spring Boot configure automatiquement votre application en fonction des
                        dépendances
                        ajoutées.
                    </p>
                    <ul>
                        <li>Configuration conditionnelle</li>
                        <li>Détection automatique</li>
                        <li>Configuration par défaut</li>
                    </ul>
                </div>

                <div class="concept-card">
                    <i class="fas fa-box"></i>
                    <h3>Spring Boot Starters</h3>
                    <p>Dépendances préconfigurées pour différents scénarios.</p>
                    <ul>
                        <li>spring-boot-starter-web</li>
                        <li>spring-boot-starter-data-jpa</li>
                        <li>spring-boot-starter-test</li>
                        <li>spring-boot-starter-security</li>
                    </ul>
                </div>

                <div class="concept-card">
                    <i class="fas fa-server"></i>
                    <h3>Serveur Embarqué</h3>
                    <p>Serveur d'application intégré.</p>
                    <ul>
                        <li>Tomcat par défaut</li>
                        <li>Jetty en alternative</li>
                        <li>Undertow disponible</li>
                    </ul>
                </div>

                <div class="concept-card">
                    <i class="fas fa-shield-alt"></i>
                    <h3>Spring Security</h3>
                    <p>Sécurité et authentification.</p>
                    <ul>
                        <li>Authentification</li>
                        <li>Autorisation</li>
                        <li>Protection CSRF</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Les codes d'État HTTP -->
        <section id="http-errors" class="section">
            <div class="subsection">
                <h3>Comprendre les Codes d'État HTTP</h3>
                <div class="concept-card">
                    <i class="fas fa-exclamation-circle"></i>

                    <h4>1. Codes 1XX - Information</h4>
                    <div class="code-section">
                        <pre><code>
        ┌─────────────────────────────────────┐
        │         Codes 1XX                   │
        │                                     │
        │ 100 → Continue                      │
        │ 101 → Switching Protocols           │
        │ 102 → Processing                    │
        └─────────────────────────────────────┘
        
        Client          Serveur
           │    Request    │
           │──────────────►│
           │              │
           │     100      │
           │◄─────────────│
           │   Continue   │
                        </code></pre>
                    </div>
                    <p>Les codes 1XX indiquent une réponse provisoire. Le client doit attendre la
                        réponse
                        finale.</p>

                    <h4>2. Codes 2XX - Succès</h4>
                    <div class="code-section">
                        <pre><code>
        ┌─────────────────────────────────────┐
        │         Codes 2XX                   │
        │                                     │
        │ 200 → OK                           │
        │ 201 → Created                      │
        │ 202 → Accepted                     │
        │ 204 → No Content                   │
        └─────────────────────────────────────┘
        
        Client          Serveur
           │    Request    │
           │──────────────►│
           │              │
           │     200      │
           │◄─────────────│
           │     OK       │
                        </code></pre>
                    </div>
                    <p>Les codes 2XX indiquent que la requête a été traitée avec succès.</p>

                    <h4>3. Codes 3XX - Redirection</h4>
                    <div class="code-section">
                        <pre><code>
        ┌─────────────────────────────────────┐
        │         Codes 3XX                   │
        │                                     │
        │ 301 → Moved Permanently            │
        │ 302 → Found (Temporary Redirect)   │
        │ 304 → Not Modified                 │
        │ 307 → Temporary Redirect           │
        └─────────────────────────────────────┘
        
        Client          Serveur
           │    Request    │
           │──────────────►│
           │              │
           │     301      │
           │◄─────────────│
           │   Location   │
           │  /new-url    │
                        </code></pre>
                    </div>
                    <p>Les codes 3XX indiquent que le client doit effectuer une action supplémentaire.
                    </p>

                    <h4>4. Codes 4XX - Erreur Client</h4>
                    <div class="code-section">
                        <pre><code>
        ┌─────────────────────────────────────┐
        │         Codes 4XX                   │
        │                                     │
        │ 400 → Bad Request                  │
        │ 401 → Unauthorized                 │
        │ 403 → Forbidden                    │
        │ 404 → Not Found                    │
        │ 405 → Method Not Allowed           │
        │ 409 → Conflict                     │
        │ 429 → Too Many Requests            │
        └─────────────────────────────────────┘
        
        Client          Serveur
           │   Bad Request │
           │──────────────►│
           │              │
           │     400      │
           │◄─────────────│
           │  Error msg   │
                        </code></pre>
                    </div>
                    <p>Les codes 4XX indiquent une erreur de la part du client.</p>

                    <h4>5. Codes 5XX - Erreur Serveur</h4>
                    <div class="code-section">
                        <pre><code>
        ┌─────────────────────────────────────┐
        │         Codes 5XX                   │
        │                                     │
        │ 500 → Internal Server Error        │
        │ 501 → Not Implemented             │
        │ 502 → Bad Gateway                 │
        │ 503 → Service Unavailable         │
        │ 504 → Gateway Timeout             │
        └─────────────────────────────────────┘
        
        Client          Serveur
           │    Request    │
           │──────────────►│
           │              │ ⚡ Erreur
           │     500      │
           │◄─────────────│
           │  Error msg   │
                        </code></pre>
                    </div>
                    <p>Les codes 5XX indiquent une erreur de la part du serveur.</p>

                    <h4>Résumé des Codes les Plus Courants</h4>
                    <ul class="features-list">
                        <li>200 : Succès - La requête a été traitée avec succès</li>
                        <li>201 : Created - Ressource créée avec succès</li>
                        <li>400 : Bad Request - Requête mal formée</li>
                        <li>401 : Unauthorized - Authentification nécessaire</li>
                        <li>403 : Forbidden - Accès interdit</li>
                        <li>404 : Not Found - Ressource non trouvée</li>
                        <li>500 : Internal Server Error - Erreur serveur</li>
                        <li>503 : Service Unavailable - Service indisponible</li>
                    </ul>

                    <div class="schema-details">
                        <p><strong>À retenir :</strong></p>
                        <ul>
                            <li>1XX : Information (rarement utilisé)</li>
                            <li>2XX : Succès</li>
                            <li>3XX : Redirection</li>
                            <li>4XX : Erreur client</li>
                            <li>5XX : Erreur serveur</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>


        <!-- Exercices -->
        <section id="exercices" class="section">
            <h2>Exercices Pratiques</h2>
            <div class="concept-card">
                <div class="exercise-container">
                    <!-- Exercice 1 -->
                    <div class="-card">
                        <h3>Exercice 1: Création d'une API REST</h3>
                        <div class="exercise-content">
                            <p class="exercise-description">
                                Créez une API REST simple pour gérer une liste de livres avec les opérations
                                CRUD.
                            </p>
                            <div class="exercise-steps">
                                <h4>Étapes:</h4>
                                <ol>
                                    <li>Créer une classe Book (id, titre, auteur, année)</li>
                                    <li>Créer un BookRepository</li>
                                    <li>Implémenter un BookController avec les endpoints CRUD</li>
                                    <li>Tester avec Postman ou cURL</li>
                                </ol>
                            </div>
                            <button class="solution-btn" data-exercise="1">Voir la solution</button>

                            <!-- Ajout de la solution -->
                            <div class="solution-content" id="solution-1">
                                <h4>Solution:</h4>

                                <div class="code-section">
                                    <h5>Book.java</h5>
                                    <pre><code>
@Entity
public class Book {
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;

private String title;
private String author;
private Integer year;

// Constructeurs, Getters et Setters
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookRepository.java</h5>
                                    <pre><code>
@Repository
public interface BookRepository extends JpaRepository<Book, Long> {
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookController.java</h5>
                                    <pre><code>
@RestController
@RequestMapping("/api/books")
public class BookController {

@Autowired
private BookRepository bookRepository;

// Récupérer tous les livres
@GetMapping
public List<Book> getAllBooks() {
return bookRepository.findAll();
}

// Récupérer un livre par ID
@GetMapping("/{id}")
public ResponseEntity<Book> getBookById(@PathVariable Long id) {
return bookRepository.findById(id)
    .map(ResponseEntity::ok)
    .orElse(ResponseEntity.notFound().build());
}

// Créer un nouveau livre
@PostMapping
public ResponseEntity<Book> createBook(@RequestBody Book book) {
Book savedBook = bookRepository.save(book);
return ResponseEntity.created(URI.create("/api/books/" + savedBook.getId()))
    .body(savedBook);
}

// Mettre à jour un livre
@PutMapping("/{id}")
public ResponseEntity<Book> updateBook(@PathVariable Long id, @RequestBody Book book) {
return bookRepository.findById(id)
    .map(existingBook -> {
        book.setId(id);
        return ResponseEntity.ok(bookRepository.save(book));
    })
    .orElse(ResponseEntity.notFound().build());
}

// Supprimer un livre
@DeleteMapping("/{id}")
public ResponseEntity<Void> deleteBook(@PathVariable Long id) {
if (!bookRepository.existsById(id)) {
    return ResponseEntity.notFound().build();
}
bookRepository.deleteById(id);
return ResponseEntity.noContent().build();
}
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>Test avec cURL</h5>
                                    <pre><code>
# Créer un livre
curl -X POST http://localhost:8080/api/books \
-H "Content-Type: application/json" \
-d '{"title":"1984","author":"George Orwell","year":1949}'

# Récupérer tous les livres
curl http://localhost:8080/api/books

# Récupérer un livre par ID
curl http://localhost:8080/api/books/1

# Mettre à jour un livre
curl -X PUT http://localhost:8080/api/books/1 \
-H "Content-Type: application/json" \
-d '{"title":"1984","author":"George Orwell","year":1948}'

# Supprimer un livre
curl -X DELETE http://localhost:8080/api/books/1
        </code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- Exercice 2 -->
                    <div class="-card">
                        <h3>Exercice 2: Validation des données</h3>
                        <div class="exercise-content">
                            <p class="exercise-description">
                                Ajoutez la validation des données à votre API de livres.
                            </p>
                            <div class="exercise-steps">
                                <h4>Étapes:</h4>
                                <ol>
                                    <li>Ajouter les annotations de validation</li>
                                    <li>Créer un gestionnaire d'erreurs global</li>
                                    <li>Tester avec des données invalides</li>
                                </ol>
                            </div>
                            <button class="solution-btn" data-exercise="2">Voir la solution</button>
                            <!-- Solution Exercice 2 -->
                            <div class="solution-content" id="solution-2">
                                <h4>Solution:</h4>

                                <div class="code-section">
                                    <h5>Book.java (avec validations)</h5>
                                    <pre><code>
@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank(message = "Le titre est obligatoire")
    @Size(min = 1, max = 100, message = "Le titre doit faire entre 1 et 100 caractères")
    private String title;
    
    @NotBlank(message = "L'auteur est obligatoire")
    @Size(min = 1, max = 50, message = "Le nom de l'auteur doit faire entre 1 et 50 caractères")
    private String author;
    
    @NotNull(message = "L'année est obligatoire")
    @Min(value = 1000, message = "L'année doit être supérieure à 1000")
    @Max(value = 9999, message = "L'année doit être inférieure à 9999")
    private Integer year;

    // Getters et Setters
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>ErrorResponse.java</h5>
                                    <pre><code>
public class ErrorResponse {
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private List<String> messages;

    public ErrorResponse(int status, String error, List<String> messages) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.messages = messages;
    }

    // Getters et Setters
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>GlobalExceptionHandler.java</h5>
                                    <pre><code>
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationErrors(MethodArgumentNotValidException ex) {
        List<String> errors = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.toList());

        ErrorResponse errorResponse = new ErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            "Erreur de validation",
            errors
        );

        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllUncaughtException(Exception ex) {
        ErrorResponse errorResponse = new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            "Erreur serveur",
            Collections.singletonList(ex.getMessage())
        );

        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookController.java (mise à jour)</h5>
                                    <pre><code>
@RestController
@RequestMapping("/api/books")
public class BookController {
    
    @Autowired
    private BookRepository bookRepository;

    @PostMapping
    public ResponseEntity<Book> createBook(@Valid @RequestBody Book book) {
        Book savedBook = bookRepository.save(book);
        return ResponseEntity.created(URI.create("/api/books/" + savedBook.getId()))
            .body(savedBook);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Book> updateBook(
            @PathVariable Long id,
            @Valid @RequestBody Book book) {
        return bookRepository.findById(id)
            .map(existingBook -> {
                book.setId(id);
                return ResponseEntity.ok(bookRepository.save(book));
            })
            .orElse(ResponseEntity.notFound().build());
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>Test avec cURL (données invalides)</h5>
                                    <pre><code>
# Test avec un titre vide
curl -X POST http://localhost:8080/api/books \
     -H "Content-Type: application/json" \
     -d '{"title":"","author":"George Orwell","year":1949}'

# Test avec une année invalide
curl -X POST http://localhost:8080/api/books \
     -H "Content-Type: application/json" \
     -d '{"title":"1984","author":"George Orwell","year":999}'

# Réponse d'erreur typique
{
    "timestamp": "2023-11-15T10:30:00",
    "status": 400,
    "error": "Erreur de validation",
    "messages": [
        "title: Le titre est obligatoire",
        "year: L'année doit être supérieure à 1000"
    ]
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>pom.xml (dépendances nécessaires)</h5>
                                    <pre><code>
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
    &lt;/dependency&gt;
    ...
&lt;/dependencies&gt;
        </code></pre>
                                </div>
                            </div>

                        </div>
                    </div>

                    <!-- Exercice 3 -->
                    <div class="-card">
                        <h3>Exercice 3: Tests unitaires</h3>
                        <div class="exercise-content">
                            <p class="exercise-description">
                                Écrivez des tests unitaires pour votre API de livres.
                            </p>
                            <div class="exercise-steps">
                                <h4>Étapes:</h4>
                                <ol>
                                    <li>Créer des tests pour le Controller</li>
                                    <li>Créer des tests pour le Service</li>
                                    <li>Utiliser MockMvc pour les tests d'intégration</li>
                                </ol>
                            </div>
                            <button class="solution-btn" data-exercise="3">Voir la solution</button>
                            <!-- Solution Exercice 3 -->
                            <div class="solution-content" id="solution-3">
                                <h4>Solution:</h4>

                                <div class="code-section">
                                    <h5>BookService.java (ajout d'une couche service)</h5>
                                    <pre><code>
@Service
public class BookService {
    private final BookRepository bookRepository;

    @Autowired
    public BookService(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

    public List<Book> getAllBooks() {
        return bookRepository.findAll();
    }

    public Book getBookById(Long id) {
        return bookRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Livre non trouvé avec l'id: " + id));
    }

    public Book createBook(Book book) {
        return bookRepository.save(book);
    }

    public Book updateBook(Long id, Book book) {
        getBookById(id); // Vérifie si le livre existe
        book.setId(id);
        return bookRepository.save(book);
    }

    public void deleteBook(Long id) {
        getBookById(id); // Vérifie si le livre existe
        bookRepository.deleteById(id);
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookServiceTest.java</h5>
                                    <pre><code>
@ExtendWith(MockitoExtension.class)
class BookServiceTest {
    @Mock
    private BookRepository bookRepository;

    @InjectMocks
    private BookService bookService;

    private Book testBook;

    @BeforeEach
    void setUp() {
        testBook = new Book();
        testBook.setId(1L);
        testBook.setTitle("Test Book");
        testBook.setAuthor("Test Author");
        testBook.setYear(2023);
    }

    @Test
    void getAllBooks_ShouldReturnListOfBooks() {
        // Arrange
        List<Book> books = Arrays.asList(testBook);
        when(bookRepository.findAll()).thenReturn(books);

        // Act
        List<Book> result = bookService.getAllBooks();

        // Assert
        assertEquals(1, result.size());
        verify(bookRepository).findAll();
    }

    @Test
    void getBookById_WithValidId_ShouldReturnBook() {
        when(bookRepository.findById(1L)).thenReturn(Optional.of(testBook));

        Book result = bookService.getBookById(1L);

        assertEquals(testBook.getTitle(), result.getTitle());
        verify(bookRepository).findById(1L);
    }

    @Test
    void getBookById_WithInvalidId_ShouldThrowException() {
        when(bookRepository.findById(1L)).thenReturn(Optional.empty());

        assertThrows(ResourceNotFoundException.class, () -> 
            bookService.getBookById(1L)
        );
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookControllerTest.java</h5>
                                    <pre><code>
@WebMvcTest(BookController.class)
class BookControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private BookService bookService;

    @Autowired
    private ObjectMapper objectMapper;

    private Book testBook;

    @BeforeEach
    void setUp() {
        testBook = new Book();
        testBook.setId(1L);
        testBook.setTitle("Test Book");
        testBook.setAuthor("Test Author");
        testBook.setYear(2023);
    }

    @Test
    void getAllBooks_ShouldReturnBooks() throws Exception {
        List<Book> books = Arrays.asList(testBook);
        when(bookService.getAllBooks()).thenReturn(books);

        mockMvc.perform(get("/api/books")
                .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].title").value("Test Book"))
                .andExpect(jsonPath("$[0].author").value("Test Author"));
    }

    @Test
    void createBook_WithValidData_ShouldReturnCreated() throws Exception {
        when(bookService.createBook(any(Book.class))).thenReturn(testBook);

        mockMvc.perform(post("/api/books")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(testBook)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.title").value("Test Book"));
    }

    @Test
    void createBook_WithInvalidData_ShouldReturnBadRequest() throws Exception {
        testBook.setTitle(""); // Invalid title

        mockMvc.perform(post("/api/books")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(testBook)))
                .andExpect(status().isBadRequest());
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookIntegrationTest.java</h5>
                                    <pre><code>
@SpringBootTest
@AutoConfigureMockMvc
class BookIntegrationTest {
    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private BookRepository bookRepository;

    @Autowired
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        bookRepository.deleteAll();
    }

    @Test
    void bookLifecycle() throws Exception {
        // Create
        Book newBook = new Book();
        newBook.setTitle("Integration Test Book");
        newBook.setAuthor("Test Author");
        newBook.setYear(2023);

        String createResponse = mockMvc.perform(post("/api/books")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(newBook)))
                .andExpect(status().isCreated())
                .andReturn().getResponse().getContentAsString();

        Book createdBook = objectMapper.readValue(createResponse, Book.class);

        // Read
        mockMvc.perform(get("/api/books/" + createdBook.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.title").value("Integration Test Book"));

        // Update
        createdBook.setTitle("Updated Title");
        mockMvc.perform(put("/api/books/" + createdBook.getId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(createdBook)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.title").value("Updated Title"));

        // Delete
        mockMvc.perform(delete("/api/books/" + createdBook.getId()))
                .andExpect(status().isNoContent());
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>pom.xml (dépendances de test)</h5>
                                    <pre><code>
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.h2database&lt;/groupId&gt;
        &lt;artifactId&gt;h2&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
        </code></pre>
                                </div>
                            </div>

                        </div>
                    </div>

                    <!-- Exercice 4 -->
                    <div class="-card">
                        <h3>Exercice 4: Sécurité avec Spring Security</h3>
                        <div class="exercise-content">
                            <p class="exercise-description">
                                Sécurisez votre API avec authentification basic.
                            </p>
                            <div class="exercise-steps">
                                <h4>Étapes:</h4>
                                <ol>
                                    <li>Configurer Spring Security</li>
                                    <li>Créer des rôles utilisateur</li>
                                    <li>Protéger les endpoints</li>
                                    <li>Tester l'authentification</li>
                                </ol>
                            </div>
                            <button class="solution-btn" data-exercise="4">Voir la solution</button>
                            <!-- Solution Exercice 4 -->
                            <div class="solution-content" id="solution-4">
                                <h4>Solution:</h4>

                                <div class="code-section">
                                    <h5>pom.xml (dépendances de sécurité)</h5>
                                    <pre><code>
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>SecurityConfig.java</h5>
                                    <pre><code>
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeHttpRequests((auth) -> auth
                .requestMatchers(HttpMethod.GET, "/api/books/**").hasAnyRole("USER", "ADMIN")
                .requestMatchers(HttpMethod.POST, "/api/books").hasRole("ADMIN")
                .requestMatchers(HttpMethod.PUT, "/api/books/**").hasRole("ADMIN")
                .requestMatchers(HttpMethod.DELETE, "/api/books/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public InMemoryUserDetailsManager userDetailsService() {
        UserDetails user = User.builder()
            .username("user")
            .password(passwordEncoder().encode("userpass"))
            .roles("USER")
            .build();

        UserDetails admin = User.builder()
            .username("admin")
            .password(passwordEncoder().encode("adminpass"))
            .roles("ADMIN")
            .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookController.java (avec annotations de sécurité)</h5>
                                    <pre><code>
@RestController
@RequestMapping("/api/books")
public class BookController {

    @PreAuthorize("hasAnyRole('USER', 'ADMIN')")
    @GetMapping
    public List<Book> getAllBooks() {
        // ...
    }

    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping
    public ResponseEntity<Book> createBook(@Valid @RequestBody Book book) {
        // ...
    }

    @PreAuthorize("hasRole('ADMIN')")
    @PutMapping("/{id}")
    public ResponseEntity<Book> updateBook(@PathVariable Long id, @Valid @RequestBody Book book) {
        // ...
    }

    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteBook(@PathVariable Long id) {
        // ...
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>Tests avec cURL</h5>
                                    <pre><code>
# Tentative sans authentification
curl http://localhost:8080/api/books

# Lecture avec utilisateur normal
curl -u user:userpass http://localhost:8080/api/books

# Création avec utilisateur normal (doit échouer)
curl -u user:userpass -X POST http://localhost:8080/api/books \
     -H "Content-Type: application/json" \
     -d '{"title":"1984","author":"George Orwell","year":1949}'

# Création avec admin (doit réussir)
curl -u admin:adminpass -X POST http://localhost:8080/api/books \
     -H "Content-Type: application/json" \
     -d '{"title":"1984","author":"George Orwell","year":1949}'
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>SecurityTest.java</h5>
                                    <pre><code>
@SpringBootTest
@AutoConfigureMockMvc
class SecurityTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void getBooks_WithoutAuth_ShouldReturnUnauthorized() throws Exception {
        mockMvc.perform(get("/api/books"))
            .andExpect(status().isUnauthorized());
    }

    @Test
    void getBooks_WithUserRole_ShouldSucceed() throws Exception {
        mockMvc.perform(get("/api/books")
            .with(user("user").roles("USER")))
            .andExpect(status().isOk());
    }

    @Test
    void createBook_WithUserRole_ShouldBeForbidden() throws Exception {
        Book book = new Book();
        book.setTitle("Test");
        book.setAuthor("Author");
        book.setYear(2023);

        mockMvc.perform(post("/api/books")
            .with(user("user").roles("USER"))
            .contentType(MediaType.APPLICATION_JSON)
            .content(new ObjectMapper().writeValueAsString(book)))
            .andExpect(status().isForbidden());
    }

    @Test
    void createBook_WithAdminRole_ShouldSucceed() throws Exception {
        Book book = new Book();
        book.setTitle("Test");
        book.setAuthor("Author");
        book.setYear(2023);

        mockMvc.perform(post("/api/books")
            .with(user("admin").roles("ADMIN"))
            .contentType(MediaType.APPLICATION_JSON)
            .content(new ObjectMapper().writeValueAsString(book)))
            .andExpect(status().isCreated());
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>application.properties (configuration optionnelle)</h5>
                                    <pre><code>
# Désactiver la page de login par défaut (pour API REST)
spring.security.basic.enabled=true
spring.security.user.name=user
spring.security.user.password=userpass

# Logs de sécurité (utile pour le développement)
logging.level.org.springframework.security=DEBUG
        </code></pre>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            </div>
        </section>


        <!-- Ressources -->
        <section id="ressources" class="section">
            <h2>Ressources Utiles</h2>
            <div class="resources-list">
                <a href="https://spring.io/projects/spring-boot" class="resource-link" target="_blank" rel="noopener">
                    <i class="fas fa-book"></i>
                    Documentation Officielle Spring Boot
                </a>
                <a href="https://start.spring.io/" class="resource-link" target="_blank" rel="noopener">
                    <i class="fas fa-play"></i>
                    Spring Initializr
                </a>
                <a href="https://github.com/spring-projects/spring-boot" class="resource-link" target="_blank"
                    rel="noopener">
                    <i class="fab fa-github"></i>
                    GitHub Spring Boot
                </a>
                <a href="https://spring.io/guides" class="resource-link" target="_blank" rel="noopener">
                    <i class="fas fa-graduation-cap"></i>
                    Spring Guides
                </a>
                <a href="https://satin-truffle-ac4.notion.site/1812ae802e2980f289aac0bb0c7378e4?v=0877a60633cc41188c1780036f37365e"
                    class="resource-link" target="_blank" rel="noopener">Spring boot - Index des notions
                    pour
                    découvrir
                    Spring Boot étape par étape</a>
            </div>

            <div class="tips-section">
                <h3>Conseils et Bonnes Pratiques</h3>
                <ul>
                    <li>Utilisez les starters appropriés pour votre projet</li>
                    <li>Suivez la convention de nommage des packages</li>
                    <li>Utilisez la validation des données</li>
                    <li>Implémentez des tests unitaires</li>
                    <li>Configurez correctement le logging</li>
                    <li>Utilisez les profiles Spring pour différents environnements</li>
                </ul>
            </div>
        </section>

        <!-- Modal -->
        <div id="modal" class="modal">
            <div class="modal-content">
                <span class="close">&times;</span>
                <div id="modal-text"></div>
            </div>
        </div>
        </>

        <!-- ScrollToTop -->
        <button id="scrollToTop" class="scroll-btn" title="Scroll to top">
            <i class="fas fa-arrow-up"></i>
        </button>

        <!-- ScrollToBottom -->
        <button id="scrollToBottom" class="scroll-btn" title="Scroll to bottom">
            <i class="fas fa-arrow-down"></i>
        </button>

        <script src="script.js"></script>
</body>

</html>