<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cours Spring Boot</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

</head>

<body>
    <nav>
        <!-- Logo -->
        <div class="logo">
            <img src="https://raw.githubusercontent.com/spring-projects/spring-framework/main/framework-docs/src/docs/spring-framework.png"
                alt="Spring Logo" class="logo">
        </div>

        <!-- Bouton Burger -->
        <button class="burger-menu" title="Menu">
            <i class="fas fa-bars"></i>
        </button>

        <!-- Liens principaux -->
        <ul class="nav-links">
            <!-- Menu Cours avec sous-menus (GÃ©nÃ©ral et Authentification) -->
            <li class="has-submenu">
                <a href="#" id="cours-link">Cours</a>
                <ul class="submenu" id="submenu-cours">
                    <!-- Colonne GÃ©nÃ©ral -->
                    <li>
                        <a href="#" class="submenu-heading" data-target="general">CrÃ©ation API REST</a>
                        <ul class="submenu-column" id="submenu-general">
                            <li><a href="#introduction">1 - Introduction</a></li>
                            <li><a href="#composants">2 - Les composants principaux</a></li>
                            <li><a href="#methodes">3 - Les mÃ©thodes HTTP</a></li>
                            <li><a href="#bean">4 - Les Beans</a></li>
                            <li><a href="#contraintes">5 - Les contraintes de validation</a></li>
                            <li><a href="#cors">6 - CORS</a></li>
                            <li><a href="#env-variables">7 - Les variables d'environnement</a></li>
                        </ul>
                    </li>

                    <!-- Colonne Authentification -->
                    <li>
                        <a href="#" class="submenu-heading" data-target="auth">Authentification</a>
                        <ul class="submenu-column" id="submenu-auth">
                            <li><a href="#auth-jwt">1 - JWT Auth</a></li>
                            <li><a href="#spring-security-intro">2 - Spring Security Intro</a></li>
                            <li><a href="#adjust-bdd">3 - Ajustement BDD</a></li>
                            <li><a href="#custom-user-details-service">4 - CustomUserDetails</a></li>
                            <li><a href="#jwt-util-service">5 - Token Service</a></li>
                            <li><a href="#JWT-Filter">6 - Filtre JWT</a></li>
                            <li><a href="#securiser-routes">7 - SÃ©curiser les routes de ton API</a></li>
                            <li><a href="#auth-endpoints">8 - Endpoints dâ€™authentification</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <!-- Autres liens principaux -->
            <li><a href="#pratique">Pratique</a></li>
            <li><a href="#concepts">Concepts ClÃ©s</a></li>
            <li><a href="#http-errors">Les codes d'Ã‰tat HTTP</a></li>
            <li><a href="#exercices">Exercices</a></li>
            <li><a href="#ressources">Ressources</a></li>
        </ul>

        <!-- ThÃ¨me (dark/light) -->
        <button id="themeToggle" title="Changer le thÃ¨me">
            <i class="fas fa-moon"></i>
        </button>
    </nav>

    <main class="container">
        <!--Introduction -->
        <section id="introduction" class="section">
            <h1>Spring Boot</h1>
            <div class="card" id="introCard">
                <h2>1 - Qu'est-ce que Spring Boot ?</h2>
                <p>Spring Boot est un projet de la Spring Framework qui simplifie le processus de crÃ©ation
                    d'applications Spring.
                    Il permet aux dÃ©veloppeurs de dÃ©marrer rapidement avec un minimum de configuration.</p>
                <ul class="features-list">
                    <li>Configuration automatique</li>
                    <li>Serveur embarquÃ©</li>
                    <li>MÃ©triques et monitoring</li>
                    <li>Production-ready</li>
                </ul>
                <button class="info-btn">En savoir plus</button>
            </div>

            <div class="card" id="prerequisCard">
                <h2>PrÃ©requis</h2>
                <ul>
                    <li>Java 8 ou supÃ©rieur</li>
                    <li>Maven ou Gradle</li>
                    <li>Connaissances en Java</li>
                    <li>IDE (IntelliJ IDEA, Eclipse, VS Code)</li>
                </ul>
                <button class="info-btn">DÃ©tails des versions</button>
            </div>
        </section>


        <!-- Les composants principaux -->
        <section id="composants" class="section">
            <h2>2 - Composants Principaux de Spring Boot</h2>

            <!-- Section EntitÃ©s -->
            <div class="subsection">
                <h3>1. Les EntitÃ©s (Entities)</h3>
                <div class="concept-card">
                    <i class="fas fa-database"></i>
                    <p>Les entitÃ©s sont des classes Java qui reprÃ©sentent les tables de la base de donnÃ©es.</p>
                    <div class="code-section">
                        <pre><code>
        @Entity
        @Table(name = "users")
        public class User {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;
        
            @Column(nullable = false)
            private String username;
        
            @Column(nullable = false)
            private String email;
        
            // Getters et Setters
        }
                        </code></pre>
                    </div>
                    <ul class="features-list">
                        <li>@Entity : Marque la classe comme une entitÃ© JPA</li>
                        <li>@Table : SpÃ©cifie le nom de la table</li>
                        <li>@Id : DÃ©finit la clÃ© primaire</li>
                        <li>@Column : Configure les propriÃ©tÃ©s de la colonne</li>
                    </ul>
                </div>
            </div>

            <!-- Section DAOs/Repositories -->
            <div class="subsection">
                <h3>2. Les DAOs/Repositories</h3>
                <div class="concept-card">
                    <i class="fas fa-layer-group"></i>
                    <p>Les repositories fournissent les mÃ©thodes d'accÃ¨s aux donnÃ©es.</p>
                    <div class="code-section">
                        <pre><code>
        @Repository
        public interface UserRepository extends JpaRepository<User, Long> {
            Optional<User> findByEmail(String email);
            List<User> findByUsernameContaining(String username);
            boolean existsByEmail(String email);
        }
                        </code></pre>
                    </div>
                    <ul class="features-list">
                        <li>HÃ©ritage de JpaRepository pour les opÃ©rations CRUD</li>
                        <li>MÃ©thodes personnalisÃ©es avec convention de nommage</li>
                        <li>RequÃªtes personnalisÃ©es avec @Query</li>
                    </ul>
                </div>
            </div>

            <!-- Section Controllers -->
            <div class="subsection">
                <h3>3. Les Controllers</h3>
                <div class="concept-card">
                    <i class="fas fa-server"></i>
                    <p>Les controllers gÃ¨rent les requÃªtes HTTP et dÃ©finissent les endpoints de l'API.</p>
                    <div class="code-section">
                        <pre><code>
        @RestController
        @RequestMapping("/api/users")
        public class UserController {
            @Autowired
            private UserService userService;
        
            @GetMapping("/{id}")
            public ResponseEntity<User> getUser(@PathVariable Long id) {
                return userService.getUser(id)
                    .map(ResponseEntity::ok)
                    .orElse(ResponseEntity.notFound().build());
            }
        
            @PostMapping
            public ResponseEntity<User> createUser(@Valid @RequestBody User user) {
                return new ResponseEntity<>(userService.createUser(user), 
                    HttpStatus.CREATED);
            }
        }
                        </code></pre>
                    </div>
                    <ul class="features-list">
                        <li>@RestController combine @Controller et @ResponseBody</li>
                        <li>@RequestMapping dÃ©finit le chemin de base</li>
                        <li>Annotations HTTP pour les mÃ©thodes</li>
                    </ul>
                </div>
            </div>

            <!-- Section Services -->
            <div class="subsection">
                <h3>4. Les Services</h3>
                <div class="concept-card">
                    <i class="fas fa-cogs"></i>
                    <p>Les services contiennent la logique mÃ©tier de l'application.</p>
                    <div class="code-section">
                        <pre><code>
    @Service
    public class UserService {
        @Autowired
        private UserRepository userRepository;

        public User createUser(User user) {
            // Validation mÃ©tier
            if (userRepository.existsByEmail(user.getEmail())) {
                throw new BusinessException("Email dÃ©jÃ  utilisÃ©");
            }
            
            // Logique mÃ©tier
            user.setCreatedDate(LocalDateTime.now());
            return userRepository.save(user);
        }

        public Optional<User> getUser(Long id) {
            return userRepository.findById(id);
        }
    }
            </code></pre>
                    </div>
                    <ul class="features-list">
                        <li>@Service : Marque la classe comme un service Spring</li>
                        <li>Contient la logique mÃ©tier</li>
                        <li>Orchestre les opÃ©rations entre Controllers et Repositories</li>
                        <li>GÃ¨re les transactions avec @Transactional</li>
                    </ul>
                </div>
            </div>

            <!-- SchÃ©ma GÃ©nÃ©ral Architecture -->
            <div class="subsection">
                <h3>Cycle Complet d'une RequÃªte</h3>
                <div class="concept-card">
                    <i class="fas fa-exchange-alt"></i>
                    <div class="code-section">
                        <pre><code>
                                                    REQUEST                                                             RESPONSE
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚          â”‚ â”€â”€â”€â–º â”‚                     Spring Boot Application                  â”‚ â”€â”€â”€â–º â”‚          â”‚
                    â”‚  Client  â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚  Client  â”‚
                    â”‚  (HTTP)  â”‚          â”‚              â”‚              â”‚               â”‚                   â”‚  (HTTP)  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â–¼              â–¼              â–¼               â–¼                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â–²
                                    â”‚Controllerâ”‚    â”‚ Service  â”‚   â”‚Repositoryâ”‚   â”‚  Entity  â”‚                 â”‚
                                    â”‚  (REST)  â”‚â”€â”€â”€â–ºâ”‚(Business)â”‚â”€â”€â–ºâ”‚  (DAO)  â”‚â”€â”€â–ºâ”‚  Model   â”‚                 â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
                                         â”‚               â”‚              â”‚               â”‚                        â”‚
                                         â”‚               â”‚              â”‚               â”‚                        â”‚
                                         â”‚               â”‚              â–¼               â”‚                        â”‚
                                         â”‚               â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚                        â”‚
                                         â”‚               â”‚         â”‚Database  â”‚         â”‚                        â”‚
                                         â”‚               â”‚         â”‚  (SQL)   â”‚         â”‚                        â”‚
                                         â”‚               â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚                        â”‚
                                         â”‚               â”‚              â–²               â”‚                        â”‚
                                         â”‚               â”‚              â”‚               â”‚                        â”‚
                                         â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚                        â”‚
                                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
                    </div>

                    <ul class="features-list">
                        <li>Client envoie requÃªte HTTP (GET, POST, PUT, DELETE)</li>
                        <li>Controller reÃ§oit la requÃªte et valide les donnÃ©es</li>
                        <li>Service applique la logique mÃ©tier</li>
                        <li>Repository prÃ©pare les opÃ©rations de base de donnÃ©es</li>
                        <li>Entity dÃ©finit la structure des donnÃ©es</li>
                        <li>Database stocke/rÃ©cupÃ¨re les donnÃ©es</li>
                        <li>Les donnÃ©es remontent la chaÃ®ne</li>
                        <li>Service traite les donnÃ©es rÃ©cupÃ©rÃ©es</li>
                        <li>Controller formate la rÃ©ponse</li>
                        <li>Client reÃ§oit la rÃ©ponse HTTP</li>
                    </ul>

                    <div class="concept-card">
                        <h4>DÃ©tail des ResponsabilitÃ©s</h4>
                        <ul class="features-list">
                            <li><strong>Controller</strong>
                                <ul>
                                    <li>Gestion des endpoints REST</li>
                                    <li>Validation des requÃªtes</li>
                                    <li>Routage vers les services appropriÃ©s</li>
                                    <li>Formatage des rÃ©ponses HTTP</li>
                                </ul>
                            </li>
                            <li><strong>Service</strong>
                                <ul>
                                    <li>Logique mÃ©tier</li>
                                    <li>Transactions</li>
                                    <li>Orchestration des opÃ©rations</li>
                                    <li>Transformation des donnÃ©es</li>
                                </ul>
                            </li>
                            <li><strong>Repository</strong>
                                <ul>
                                    <li>OpÃ©rations CRUD</li>
                                    <li>RequÃªtes personnalisÃ©es</li>
                                    <li>Mapping Object-Relationnel</li>
                                </ul>
                            </li>
                            <li><strong>Entity</strong>
                                <ul>
                                    <li>Mapping avec la base de donnÃ©es</li>
                                    <li>Validation des donnÃ©es</li>
                                    <li>Relations entre entitÃ©s</li>
                                </ul>
                            </li>
                        </ul>
                    </div>

                    <div class="concept-card">
                        <h4>Flux de DonnÃ©es Typique</h4>
                        <ul class="features-list">
                            <li>â¬‡ï¸ Flux descendant (Request)
                                <ul>
                                    <li>Validation des donnÃ©es d'entrÃ©e</li>
                                    <li>Transformation en objets mÃ©tier</li>
                                    <li>Persistance des donnÃ©es</li>
                                </ul>
                            </li>
                            <li>â¬†ï¸ Flux montant (Response)
                                <ul>
                                    <li>RÃ©cupÃ©ration des donnÃ©es</li>
                                    <li>Transformation en DTOs</li>
                                    <li>Formatage de la rÃ©ponse</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>


        <!-- Les mÃ©thodes HTTP -->
        <section id="methodes" class="section">
            <h2>3 - Les MÃ©thodes HTTP</h2>
            <!-- Section MÃ©thodes HTTP -->
            <div class="subsection">
                <h3>5. Les MÃ©thodes HTTP</h3>
                <div class="concept-card">
                    <i class="fas fa-exchange-alt"></i>

                    <!-- GET -->
                    <h4>GET</h4>
                    <div class="code-section">
                        <pre><code>
Client                    Serveur
   â”‚        GET /users       â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  â”‚
   â”‚                        â”‚ [Lecture]
   â”‚       [DonnÃ©es]        â”‚
   â”‚   [Status: 200 OK]     â”‚
   â”‚   [Error: 404 Not Found]â”‚
   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
        </code></pre>
                    </div>
                    <p>UtilisÃ© pour rÃ©cupÃ©rer des donnÃ©es sans les modifier</p>

                    <!-- POST -->
                    <h4>POST</h4>
                    <div class="code-section">
                        <pre><code>
Client                    Serveur
   â”‚    POST /users         â”‚
   â”‚   [DonnÃ©es]           â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚
   â”‚                       â”‚ [CrÃ©ation]
   â”‚    [Nouvel ID]        â”‚
   â”‚ [Status: 201 Created] â”‚
   â”‚ [Error: 400 Bad Request]â”‚
   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-â”‚
        </code></pre>
                    </div>
                    <p>UtilisÃ© pour crÃ©er une nouvelle ressource</p>

                    <!-- PUT -->
                    <h4>PUT</h4>
                    <div class="code-section">
                        <pre><code>
Client                    Serveur
   â”‚    PUT /users/1       â”‚
   â”‚   [DonnÃ©es]          â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
   â”‚                      â”‚ [Remplacement]
   â”‚     [Status]         â”‚
   â”‚ [Status: 200 OK]     â”‚
   â”‚ [Error: 404 Not Found]â”‚
   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-â”‚
        </code></pre>
                    </div>
                    <p>UtilisÃ© pour mettre Ã  jour complÃ¨tement une ressource</p>

                    <!-- PATCH -->
                    <h4>PATCH</h4>
                    <div class="code-section">
                        <pre><code>
Client                    Serveur
   â”‚   PATCH /users/1      â”‚
   â”‚  [Modifications]      â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
   â”‚                      â”‚ [Mise Ã  jour]
   â”‚     [Status]         â”‚
   â”‚ [Status: 200 OK]     â”‚
   â”‚ [Error: 404 Not Found]â”‚
   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-â”‚
        </code></pre>
                    </div>
                    <p>UtilisÃ© pour mettre Ã  jour partiellement une ressource</p>

                    <!-- DELETE -->
                    <h4>DELETE</h4>
                    <div class="code-section">
                        <pre><code>
Client                    Serveur
   â”‚  DELETE /users/1      â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
   â”‚                      â”‚ [Suppression]
   â”‚     [Status]         â”‚
   â”‚[Status: 204 No Content]â”‚
   â”‚[Error: 404 Not Found] â”‚
   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-â”‚
        </code></pre>
                    </div>
                    <p>UtilisÃ© pour supprimer une ressource</p>

                    <ul class="features-list">
                        <li>GET : Lecture (idempotent)</li>
                        <li>POST : CrÃ©ation</li>
                        <li>PUT : Mise Ã  jour complÃ¨te (idempotent)</li>
                        <li>PATCH : Mise Ã  jour partielle</li>
                        <li>DELETE : Suppression (idempotent)</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Les Beans -->
        <section id="bean" class="section">
            <div class="subsection">
                <h3>4 - Les Beans, l'Injection de DÃ©pendances et l'IoC</h3>
                <div class="concept-card">
                    <i class="fas fa-cogs"></i>

                    <h4>1. Qu'est-ce qu'un Bean ?</h4>
                    <p>Un Bean est simplement un objet Java qui est crÃ©Ã© et gÃ©rÃ© par Spring. Imaginez-le comme une
                        brique de base de votre application.</p>
                    <div class="code-section">
                        <pre><code>
        // Un simple Bean Spring
        @Component  // Cette annotation dit Ã  Spring "Ceci est un Bean"
        public class UserService {
            // Contenu de la classe
        }
                        </code></pre>
                    </div>

                    <h4>2. Le Conteneur IoC (Inversion of Control)</h4>
                    <div class="code-section">
                        <pre><code>
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         Spring IoC Container        â”‚
        â”‚                                     â”‚
        â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
        â”‚   â”‚ Bean 1   â”‚      â”‚ Bean 2   â”‚   â”‚
        â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
        â”‚                                     â”‚
        â”‚    Spring crÃ©e et gÃ¨re les Beans    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        </code></pre>
                    </div>
                    <p>Le conteneur IoC est comme une usine qui :</p>
                    <ul class="features-list">
                        <li>CrÃ©e les objets (Beans)</li>
                        <li>Les configure</li>
                        <li>Les assemble</li>
                        <li>GÃ¨re leur cycle de vie</li>
                    </ul>

                    <h4>3. L'Injection de DÃ©pendances (DI)</h4>
                    <p>Au lieu de crÃ©er nos objets nous-mÃªmes, Spring les "injecte" lÃ  oÃ¹ nous en avons besoin.</p>

                    <h5>3.1 Sans Injection de DÃ©pendances âŒ</h5>
                    <div class="code-section">
                        <pre><code>
        public class UserService {
            // CrÃ©ation manuelle = Forte dÃ©pendance
            private UserRepository repository = new UserRepository();
        }
                        </code></pre>
                    </div>

                    <h5>3.2 Avec Injection de DÃ©pendances âœ…</h5>
                    <div class="code-section">
                        <pre><code>
        @Service
        public class UserService {
            private final UserRepository repository;
            
            // Spring injecte automatiquement UserRepository
            public UserService(UserRepository repository) {
                this.repository = repository;
            }
        }
                        </code></pre>
                    </div>

                    <h4>4. Les DiffÃ©rentes FaÃ§ons d'Injecter</h4>
                    <div class="code-section">
                        <pre><code>
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚     MÃ©thodes d'Injection          â”‚
        â”‚                                    â”‚
        â”‚ 1. Constructor â”€â”€â”€â”€â–º RecommandÃ©e   â”‚
        â”‚ 2. Setter     â”€â”€â”€â”€â–º Alternative    â”‚
        â”‚ 3. Field      â”€â”€â”€â”€â–º DÃ©conseillÃ©e  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        // 1. Constructor Injection (RecommandÃ©e)
        @Service
        public class UserService {
            private final UserRepository repository;
            
            public UserService(UserRepository repository) {
                this.repository = repository;
            }
        }
        
        // 2. Setter Injection
        @Service
        public class UserService {
            private UserRepository repository;
            
            @Autowired
            public void setRepository(UserRepository repository) {
                this.repository = repository;
            }
        }
        
        // 3. Field Injection (Ã‰viter)
        @Service
        public class UserService {
            @Autowired
            private UserRepository repository;
        }
                        </code></pre>
                    </div>

                    <h4>5. Configuration des Beans</h4>
                    <p>Il existe deux faÃ§ons principales de dÃ©clarer des Beans :</p>

                    <h5>5.1 Annotations (MÃ©thode simple)</h5>
                    <div class="code-section">
                        <pre><code>
        @Component     // Pour les composants gÃ©nÃ©riques
        @Service       // Pour la couche service
        @Repository    // Pour la couche d'accÃ¨s aux donnÃ©es
        @Controller    // Pour les contrÃ´leurs web
                        </code></pre>
                    </div>

                    <h5>5.2 Configuration Java (Plus de contrÃ´le)</h5>
                    <div class="code-section">
                        <pre><code>
        @Configuration
        public class AppConfig {
            @Bean
            public UserService userService() {
                // Configuration personnalisÃ©e
                return new UserService(userRepository());
            }
        }
                        </code></pre>
                    </div>

                    <h4>6. Cycle de vie simplifiÃ© d'un Bean</h4>
                    <div class="code-section">
                        <pre><code>
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚        Cycle de vie Bean            â”‚
        â”‚                                     â”‚
        â”‚ 1. Spring crÃ©e le Bean              â”‚
        â”‚          â†“                          â”‚
        â”‚ 2. Injection des dÃ©pendances        â”‚
        â”‚          â†“                          â”‚
        â”‚ 3. @PostConstruct                   â”‚
        â”‚          â†“                          â”‚
        â”‚ 4. Bean prÃªt Ã  l'utilisation       â”‚
        â”‚          â†“                          â”‚
        â”‚ 5. @PreDestroy                      â”‚
        â”‚          â†“                          â”‚
        â”‚ 6. Bean dÃ©truit                     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        </code></pre>
                    </div>

                    <h4>Points ClÃ©s Ã  Retenir</h4>
                    <ul class="features-list">
                        <li>Les Beans sont des objets gÃ©rÃ©s par Spring</li>
                        <li>L'IoC nous libÃ¨re de la crÃ©ation manuelle d'objets</li>
                        <li>L'injection de dÃ©pendances rend le code plus flexible</li>
                        <li>PrÃ©fÃ©rez l'injection par constructeur</li>
                        <li>Utilisez @Component (ou ses variantes) pour les cas simples</li>
                        <li>Utilisez @Configuration/@Bean pour plus de contrÃ´le</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Les Contraintes de Validation -->
        <section id="contraintes" class="section">
            <div class="subsection">
                <h3>5 - Les Contraintes de Validation avec Spring Boot</h3>
                <div class="concept-card">
                    <i class="fas fa-check-circle"></i>

                    <h4>1. Introduction aux Validations</h4>
                    <p>Les contraintes de validation permettent de s'assurer que les donnÃ©es reÃ§ues par notre
                        application respectent certaines rÃ¨gles avant d'Ãªtre traitÃ©es.</p>

                    <h4>2. Mise en Place des Validations</h4>
                    <p>Tout d'abord, ajoutez la dÃ©pendance dans votre pom.xml :</p>
                    <div class="code-section">
                        <pre><code>
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
    &lt;/dependency&gt;
                </code></pre>
                    </div>

                    <h4>3. Les Annotations de Validation Courantes</h4>
                    <div class="code-section">
                        <pre><code>
@NotNull          : La valeur ne doit pas Ãªtre null
@NotEmpty         : La chaÃ®ne/collection ne doit pas Ãªtre vide
@NotBlank         : La chaÃ®ne ne doit pas Ãªtre vide ou constituÃ©e uniquement d'espaces
@Min(value)       : Valeur minimale pour les nombres
@Max(value)       : Valeur maximale pour les nombres
@Size             : Taille d'une chaÃ®ne, collection, tableau
@Email            : Format d'email valide
@Pattern          : Expression rÃ©guliÃ¨re Ã  respecter
@URL              : Format d'URL valide
@Positive         : Valeur numÃ©rique strictement positive
@Negative         : Valeur numÃ©rique strictement nÃ©gative
@PositiveOrZero   : Valeur numÃ©rique positive ou nulle
@NegativeOrZero   : Valeur numÃ©rique nÃ©gative ou nulle
@Past             : Date dans le passÃ©
@Future           : Date dans le futur
@PastOrPresent    : Date dans le passÃ© ou prÃ©sent
@FutureOrPresent  : Date dans le futur ou prÃ©sent
@Valid            : Validation en cascade des objets imbriquÃ©s
                        </code></pre>
                    </div>

                    <h4>3.1 Placement des Contraintes de Validation</h4>
                    <div class="code-section">
                        <pre><code>
                    public class User {
                        // 1ï¸âƒ£ Sur l'attribut : Validation directe de la donnÃ©e
                        @NotNull
                        private String name;
                    
                        // 2ï¸âƒ£ Sur le getter : Validation aprÃ¨s transformation
                        private String email;
                        
                        @Email
                        public String getEmail() {
                            return email.toLowerCase(); // Validation aprÃ¨s transformation
                        }
                    }
                        </code></pre>
                    </div>

                    <p>Le placement des contraintes dÃ©pend du moment souhaitÃ© pour la validation :</p>
                    <ul class="features-list">
                        <li><strong>Sur l'attribut</strong> : Pour une validation immÃ©diate de la donnÃ©e brute</li>
                        <li><strong>Sur le getter</strong> : Pour valider aprÃ¨s une Ã©ventuelle transformation de la
                            donnÃ©e</li>
                    </ul>


                    <h4>4. Exemple Pratique</h4>
                    <p>CrÃ©ons une classe User avec des validations :</p>
                    <div class="code-section">
                        <pre><code>
    import javax.validation.constraints.*;

    public class User {
        @NotNull(message = "L'id ne peut pas Ãªtre null")
        private Long id;

        @NotBlank(message = "Le nom est obligatoire")
        @Size(min = 2, max = 50, message = "Le nom doit faire entre 2 et 50 caractÃ¨res")
        private String name;

        @Email(message = "Format d'email invalide")
        private String email;

        @Min(value = 18, message = "L'Ã¢ge minimum est 18 ans")
        private int age;
    }
                </code></pre>
                    </div>

                    <h4>5. Validation dans le Controller</h4>
                    <div class="code-section">
                        <pre><code>
    @RestController
    @RequestMapping("/api/users")
    public class UserController {

        @PostMapping
        public ResponseEntity&lt;User&gt; createUser(@Valid @RequestBody User user) {
            // Si la validation Ã©choue, Spring retourne automatiquement 
            // une erreur 400 Bad Request
            return ResponseEntity.ok(userService.save(user));
        }
    }
                </code></pre>
                    </div>

                    <h4>5.1 Utilisation ComplÃ¨te de @Valid dans le Controller</h4>
                    <p>L'annotation @Valid doit Ãªtre placÃ©e systÃ©matiquement avant @RequestBody pour toutes les
                        opÃ©rations
                        modifiant des donnÃ©es :</p>
                    <div class="code-section">
                        <pre><code>
                    @RestController
                    @RequestMapping("/api/products")
                    public class ProductController {
                    
                        @PostMapping  // CrÃ©ation
                        public ResponseEntity&lt;Product&gt; createProduct(@Valid @RequestBody Product product) {
                            return ResponseEntity.status(HttpStatus.CREATED).body(productService.save(product));
                        }
                    
                        @PutMapping("/{id}")  // Mise Ã  jour complÃ¨te
                        public ResponseEntity&lt;Product&gt; updateProduct(
                            @PathVariable Long id, 
                            @Valid @RequestBody Product product) {
                            return ResponseEntity.ok(productService.update(id, product));
                        }
                    
                        @PatchMapping("/{id}")  // Mise Ã  jour partielle
                        public ResponseEntity&lt;Product&gt; partialUpdateProduct(
                            @PathVariable Long id, 
                            @Valid @RequestBody Product product) {
                            return ResponseEntity.ok(productService.partialUpdate(id, product));
                        }
                    }
                        </code></pre>
                    </div>

                    <ul class="features-list">
                        <li>@Valid est nÃ©cessaire pour toute opÃ©ration recevant des donnÃ©es (POST, PUT, PATCH)</li>
                        <li>Se place toujours avant @RequestBody</li>
                        <li>Non nÃ©cessaire pour les opÃ©rations de lecture (GET) ou suppression (DELETE)</li>
                        <li>Garantit la validation des donnÃ©es avant tout traitement</li>
                    </ul>


                    <h4>6. Gestion PersonnalisÃ©e des Erreurs</h4>
                    <div class="code-section">
                        <pre><code>
    @ControllerAdvice
    public class ValidationExceptionHandler {

        @ExceptionHandler(MethodArgumentNotValidException.class)
        public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(
            MethodArgumentNotValidException ex) {
            
            Map&lt;String, String&gt; errors = new HashMap<>();
            
            ex.getBindingResult().getAllErrors().forEach(error -> {
                String fieldName = ((FieldError) error).getField();
                String errorMessage = error.getDefaultMessage();
                errors.put(fieldName, errorMessage);
            });
            
            return ResponseEntity.badRequest().body(errors);
        }
    }
                </code></pre>
                    </div>

                    <h4>7. Exemple de Validation PersonnalisÃ©e</h4>
                    <p>CrÃ©ation d'une annotation personnalisÃ©e :</p>
                    <div class="code-section">
                        <pre><code>
    // L'annotation
    @Target({ElementType.FIELD})
    @Retention(RetentionPolicy.RUNTIME)
    @Constraint(validatedBy = PasswordValidator.class)
    public @interface StrongPassword {
        String message() default "Mot de passe trop faible";
        Class<?>[] groups() default {};
        Class<? extends Payload>[] payload() default {};
    }

    // Le validateur
    public class PasswordValidator implements ConstraintValidator&lt;StrongPassword, String&gt; {
        @Override
        public boolean isValid(String value, ConstraintValidatorContext context) {
            return value != null && 
                   value.length() >= 8 && 
                   value.matches(".*[A-Z].*") && 
                   value.matches(".*[a-z].*") && 
                   value.matches(".*[0-9].*");
        }
    }

    // Utilisation
    public class User {
        @StrongPassword
        private String password;
    }
                </code></pre>
                    </div>

                    <h4>Points ClÃ©s Ã  Retenir</h4>
                    <ul class="features-list">
                        <li>Les validations permettent de vÃ©rifier les donnÃ©es avant traitement</li>
                        <li>@Valid active la validation sur un objet</li>
                        <li>Les messages d'erreur peuvent Ãªtre personnalisÃ©s</li>
                        <li>PossibilitÃ© de crÃ©er des validations personnalisÃ©es</li>
                        <li>Spring gÃ¨re automatiquement les erreurs de validation</li>
                        <li>Les validations amÃ©liorent la robustesse de l'application</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- CORS et Communication React-Spring -->
        <section id="cors" class="section">
            <div class="subsection">
                <h3>6 - IntÃ©gration React et Spring Boot : Configuration et Tests avec CORS</h3>
                <div class="concept-card">
                    <i class="fas fa-code-branch"></i>

                    <h4>1. Contexte et Objectif</h4>
                    <p>Dans un projet moderne, le backend (avec Spring Boot) et le frontend (avec React) doivent
                        fonctionner ensemble. Mais par dÃ©faut, ils ne peuvent pas communiquer librement s'ils sont
                        exÃ©cutÃ©s sur des serveurs ayant des origines diffÃ©rentes (par exemple, backend sur
                        <code>http://localhost:8080</code> et frontend sur <code>http://localhost:3000</code>). C'est
                        ici que le <b>CORS</b> (Cross-Origin Resource Sharing) entre en jeu.
                    </p>

                    <h4>2. Quâ€™est-ce que CORS ?</h4>
                    <p>
                        CORS est une *politique de sÃ©curitÃ©* utilisÃ©e par les navigateurs pour empÃªcher des requÃªtes
                        provenant d'une origine non autorisÃ©e. Avec CORS correctement configurÃ©, le backend autorisera
                        React Ã  lui envoyer des requÃªtes.
                    </p>

                    <div class="code-section schema">
                        <pre>
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       RequÃªte API        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚ Frontend Reactâ”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ Backend Springâ”‚
                  â”‚http://localhost:3000 â”‚                â”‚http://localhost:8080â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       RÃ©ponse API       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            ğŸš«<b>Sans configuration CORS :</b> Erreur bloquÃ©e par le navigateur.
                            âœ…<b>Avec configuration CORS :</b> Communication rÃ©ussie.
                  </pre>
                    </div>

                    <h4>3. Mise en Place de la Communication</h4>
                    <p>Voici comment configurer CORS et connecter les deux applications de maniÃ¨re fluide.</p>

                    <h5>Ã‰tape 1 : CrÃ©er un Backend Spring Boot</h5>
                    <p>CrÃ©ez un projet Spring Boot avec une simple API REST. Par exemple :</p>
                    <div class="code-section">
                        <pre><code>
          @RestController
          @RequestMapping("/api")
          public class TestController {
              @GetMapping("/test")
              public String test() {
                  return "Hello depuis Spring Boot !";
              }
          }
                  </code></pre>
                    </div>

                    <h5>Ã‰tape 2 : Configurer CORS dans Spring Boot</h5>
                    <p>Ajoutez une configuration CORS pour permettre Ã  React dâ€™accÃ©der au backend :</p>
                    <div class="code-section">
                        <pre><code>
          @Configuration
          public class CorsConfig implements WebMvcConfigurer {
              @Override
              public void addCorsMappings(CorsRegistry registry) {
                  registry.addMapping("/**") // Appliquer Ã  tous les endpoints
                          .allowedOrigins("http://localhost:3000") // Autorise React
                          .allowedMethods("GET", "POST", "PUT", "DELETE");
              }
          }
                  </code></pre>
                    </div>

                    <h5>Ã‰tape 3 : CrÃ©er un Frontend React</h5>
                    <p>CrÃ©ez un composant React pour tester l'appel au backend :</p>
                    <div class="code-section">
                        <pre><code>
          import React, { useEffect, useState } from 'react';
          
          const TestComponent = () => {
              const [data, setData] = useState("");
          
              useEffect(() => {
                  fetch("http://localhost:8080/api/test")
                      .then(response => response.text())
                      .then(data => setData(data))
                      .catch(error => console.error("Erreur :", error));
              }, []);
          
              return (
                  <div>
                      <h1>Test API</h1>
                      <p>RÃ©ponse du backend : {data}</p>
                  </div>
              );
          };
          
          export default TestComponent;
                  </code></pre>
                    </div>

                    <h5>Ã‰tape 4 : Tester la Communication</h5>
                    <p>1. Lancez le backend Spring Boot sur le port 8080.
                        2. Lancez le frontend React sur le port 3000.
                        3. AccÃ©dez au composant React et vÃ©rifiez que la rÃ©ponse du backend s'affiche correctement.</p>

                    <div class="code-section schema">
                        <pre>
                  ğŸŒ Frontend React       ğŸ”„        Backend Spring Boot
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚1. Appel fetch() depuis React                â”‚
                  â”‚   URL : http://localhost:8080/api/test      â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â¬† CORS configurÃ© â¬‡
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚2. RÃ©ponse JSON ou String : "Hello depuisâ€¦"  â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  </pre>
                    </div>

                    <h4>4. RÃ©soudre les ProblÃ¨mes Courants</h4>
                    <div class="features-list">
                        <ul>
                            <li><b>Erreur CORS :</b> VÃ©rifiez que l'origine utilisÃ©e dans Spring Boot correspond Ã  celle
                                du
                                frontend.</li>
                            <li><b>Backend inaccessible :</b> Assurez-vous que le backend tourne bien Ã  l'adresse
                                <code>http://localhost:8080</code>.
                            </li>
                            <li><b>Pas de rÃ©ponse :</b> VÃ©rifiez que votre URL dans React est correcte.</li>
                        </ul>
                    </div>

                    <h4>5. Bonnes Pratiques</h4>
                    <ul class="features-list">
                        <li>Utilisez un composant test (comme notre `TestController`) pour isoler les problÃ¨mes.</li>
                        <li>Configurez CORS globalement dans Spring Boot pour un dÃ©veloppement fluide.</li>
                        <li>Gardez les tests React pour vÃ©rifier rapidement la connectivitÃ© lors de modifications.</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Les variables d'environnement -->
        <section id="env-variables" class="section">
            <div class="subsection">
                <h3>7 - Les Variables dâ€™Environnement</h3>
                <div class="concept-card">
                    <i class="fas fa-lock"></i>

                    <h4>1. Introduction</h4>
                    <p>Souviens-toi, dans ton fichier <code>application.properties</code>, tu as peut-Ãªtre dÃ©fini des
                        informations telles que :</p>
                    <div class="code-section">
                        <pre><code>
          spring.datasource.url=jdbc:mysql://localhost:3306/visiotech_db?createDatabaseIfNotExist=true
          spring.datasource.username=your_mysql_username # ğŸ‘ˆ Ã  remplacer
          spring.datasource.password=your_mysql_password # ğŸ‘ˆ Ã  remplacer
                  </code></pre>
                    </div>
                    <p>Le problÃ¨me, c'est que ces informations sont **sensibles**. Tu ne veux pas qu'elles soient
                        visibles par tout le monde, surtout si ton code est versionnÃ© sur GitHub.</p>
                    <p>Pour rÃ©soudre ce problÃ¨me, tu peux utiliser des **variables dâ€™environnement**, un outil puissant
                        pour sÃ©curiser et structurer les configurations de ton application. ğŸŒŸ</p>

                    <div class="schema">
                        <pre>
          ğŸ’» Ton application        ğŸ”’ Variables d'environnement
                 â†“                               â†“
              Utilise les valeurs      Stocke les infos sensibles
                    lors de                 dans un systÃ¨me
              l'exÃ©cution.              sÃ©curisÃ© et externe.
                  </pre>
                    </div>

                    <h4>2. Pourquoi utiliser des Variables dâ€™Environnement ?</h4>
                    <ul class="features-list">
                        <li><b>ğŸ”’ SÃ©curitÃ© :</b> Les informations comme les mots de passe sont stockÃ©es en dehors du
                            code source, Ã©vitant ainsi tout partage accidentel.</li>
                        <li><b>ğŸš€ PortabilitÃ© :</b> Change les configurations en fonction des diffÃ©rentes Ã©tapes du
                            projet (dÃ©veloppement, test, production).</li>
                        <li><b>âš™ï¸ FacilitÃ© dâ€™utilisation :</b> Modifie les paramÃ¨tres sans toucher au code ou aux
                            fichiers versionnÃ©s.</li>
                    </ul>

                    <h4>3. Mise en Place avec Spring Boot et spring-dotenv</h4>
                    <p>Voyons comment implÃ©menter des variables dâ€™environnement dans un projet Spring Boot de maniÃ¨re
                        sÃ©curisÃ©e et propre. ğŸ› ï¸</p>

                    <h5>3.1 Ajoute la DÃ©pendance Maven</h5>
                    <p>Tout commence par lâ€™ajout de la dÃ©pendance suivante dans <code>pom.xml</code> :</p>
                    <div class="code-section">
                        <pre><code>
          <dependency>
              <groupId>me.paulschwarz</groupId>
              <artifactId>spring-dotenv</artifactId>
              <version>3.0.0</version>
          </dependency>
                  </code></pre>
                    </div>
                    <p><b>ğŸ’¡ Tip :</b> AprÃ¨s avoir modifiÃ© ton <code>pom.xml</code>, nâ€™oublie pas de <b>refresh</b> ton
                        projet Maven !</p>

                    <h5>3.2 CrÃ©e le Fichier <code>.env</code></h5>
                    <p>Ajoute un fichier <code>.env</code> Ã  la racine de ton projet (au mÃªme niveau que le dossier
                        <code>src</code>) et configure-y tes infos sensibles :
                    </p>
                    <div class="code-section">
                        <pre><code>
          DB_URL=jdbc:mysql://localhost:3306/visiotech_db?createDatabaseIfNotExist=true
          DB_USERNAME=your_mysql_username
          DB_PASSWORD=your_mysql_password
                  </code></pre>
                    </div>
                    <p>Voici oÃ¹ placer le fichier :</p>
                    <div class="schema">
                        <pre>
          ğŸ”– Mon Projet Spring Boot
          â”œâ”€â”€ src/
          â”œâ”€â”€ pom.xml
          â””â”€â”€ .env  ğŸ‘ˆ Ajoute ton fichier ici
                  </pre>
                    </div>

                    <h5>3.3 Ignore le Fichier <code>.env</code> dans Git</h5>
                    <p>Ajoute <code>.env</code> Ã  ton fichier <code>.gitignore</code> pour t'assurer qu'il ne soit
                        jamais versionnÃ© :</p>
                    <div class="code-section">
                        <pre><code>
          # Ignorer les fichiers contenant des variables sensibles
          .env
                  </code></pre>
                    </div>
                    <p><b>âš ï¸ ATTENTION :</b> Ne partage jamais ce fichier, car il contient des informations sensibles.
                    </p>

                    <h5>3.4 Ajoute un fichier <code>.envsample</code></h5>
                    <p>CrÃ©e un fichier <code>.envsample</code> pour partager avec dâ€™autres dÃ©veloppeurs un
                        <i>template</i> indiquant les variables nÃ©cessaires, sans leurs valeurs :
                    </p>
                    <div class="code-section">
                        <pre><code>
          DB_URL=
          DB_USERNAME=
          DB_PASSWORD=
                  </code></pre>
                    </div>
                    <p>Ainsi, chaque dÃ©veloppeur peut copier ce fichier, le renommer en <code>.env</code> et remplir les
                        valeurs selon ses besoins.</p>

                    <h5>3.5 Remplace les Configurations dans <code>application.properties</code></h5>
                    <p>Ã‰dite le fichier <code>application.properties</code> pour rÃ©fÃ©rencer tes variables
                        dâ€™environnement. Utilise la syntaxe <code>${VAR_NAME}</code>, comme ceci :</p>
                    <div class="code-section">
                        <pre><code>
          spring.datasource.url=${DB_URL}
          spring.datasource.username=${DB_USERNAME}
          spring.datasource.password=${DB_PASSWORD}
          spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
          
          spring.sql.init.mode=always
          logging.level.org.springframework.jdbc.core=DEBUG
                  </code></pre>
                    </div>
                    <p>Lorsque tu dÃ©marres lâ€™application, les valeurs de <code>.env</code> sont automatiquement
                        injectÃ©es. ğŸš€</p>

                    <h4>4. SchÃ©ma de Fonctionnement</h4>
                    <div class="schema">
                        <pre>
          ğŸŒ Ton application Spring Boot
                 â†•
          ğŸ“„ application.properties â–¶ RÃ©fÃ©rence les variables dâ€™environnement
                 â†•
          ğŸ“‚ .env â–¶ Contient les valeurs sensibles (non partagÃ©)
                  </pre>
                    </div>

                    <h4>5. Bonnes Pratiques</h4>
                    <ul class="features-list">
                        <li>Ajoute <code>.env</code> Ã  <code>.gitignore</code>.</li>
                        <li>CrÃ©e un <code>.envsample</code> pour guider tes collÃ¨gues.</li>
                        <li>Ne jamais mettre de valeurs sensibles directement dans <code>application.properties</code>.
                        </li>
                        <li>Utilise des outils comme <b>Vault</b> ou <b>Secrets Manager</b> si ton application est en
                            production.</li>
                    </ul>

                    <h4>6. Ce que tu as appris</h4>
                    <ul class="features-list">
                        <li>Comprendre la valeur et lâ€™usage des variables dâ€™environnement.</li>
                        <li>Configurer un fichier <code>.env</code> dans un projet Spring Boot avec la librairie
                            <code>spring-dotenv</code>.
                        </li>
                        <li>Ã‰viter de partager des donnÃ©es sensibles dans Git.</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Mise en place de l'authentification -->
        <section id="auth-jwt" class="section">
            <div class="subsection">
                <h2>8 - Mise en Place de lâ€™Authentification</h2>
                <div class="concept-card">
                    <p>ğŸš€ Dans ce chapitre, tu vas apprendre Ã  utiliser les **JWT (JSON Web Tokens)** pour mettre en
                        place
                        un systÃ¨me dâ€™authentification sÃ©curisÃ© dans ton application. Ils permettront de restreindre
                        lâ€™accÃ¨s
                        aux endpoints de ton API en fonction des rÃ´les dâ€™utilisateur.</p>

                    <h3>ğŸ“š Objectifs</h3>
                    <ul>
                        <li>âœ… DiffÃ©rencier authentification et autorisation</li>
                        <li>âœ… Comprendre comment un JWT facilite lâ€™authentification</li>
                        <li>âœ… Visualiser le sÃ©quenÃ§age dâ€™une authentification</li>
                        <li>âœ… ÃŠtre capable de comprendre et structurer un JWT</li>
                    </ul>
                </div>

                <div class="subsection">
                    <h3>Authentification VS Autorisation</h3>
                    <p>La premiÃ¨re chose est de bien faire la diffÃ©rence entre **authentification** et
                        **autorisation**â€¯:
                    </p>
                </div>

                <div class="concept-card">
                    <h4>ğŸ”‘ Authentification</h4>
                    <ul>
                        <li><strong>Objectif :</strong> VÃ©rifie lâ€™identitÃ© de lâ€™utilisateur.</li>
                        <li><strong>Exemple :</strong> Lâ€™utilisateur fournit un email + mot de passe pour prouver son
                            identitÃ© (login).</li>
                    </ul>
                </div>
                <div class="concept-card">
                    <h4>ğŸš¦ Autorisation</h4>
                    <ul>
                        <li><strong>Objectif :</strong> VÃ©rifie ce que lâ€™utilisateur a le droit de faire.</li>
                        <li><strong>Exemple :</strong> Un utilisateur connectÃ© avec un rÃ´le `ADMIN` peut modifier
                            dâ€™autres utilisateurs, mais un `USER` ne peut que visualiserÂ son propre profil.</li>
                    </ul>
                </div>

                <div class="schema">
                    <h5>ğŸ–¼ï¸ RÃ©sumÃ© visuel</h5>
                    <pre>
          1ï¸âƒ£ AUTHENTIFICATION :
          
          ğŸ”‘ Utilisateur :
             â¡ï¸ Email : user@example.com
             â¡ï¸ Mot de passe : password123
          
          Serveur : âœ” Authentification rÃ©ussie, voici ton <token> !
          
          ---
          
          2ï¸âƒ£ AUTORISATION
          ğŸ›‚ Avec le token :
          
            ğŸ”“ AccÃ¨s autorisÃ© (rÃ´le : ADMIN)
            ğŸ”’ AccÃ¨s refusÃ© (pas le bon rÃ´le)
                </pre>
                </div>
            </div>

            <div class="subsection">
                <h3>Le Workflow : Comment fonctionne lâ€™authentification JWT ?</h3>
                <p>Pour illustrer le process complet dâ€™authentification avec JWT, voici un schÃ©ma basÃ© sur un cas
                    classique :</p>

                <div class="schema">
                    <h5>ğŸ—ºï¸ Ã‰tapes dâ€™authentification avec JWT</h5>
                    <pre>
          1ï¸âƒ£ CrÃ©ation de Compte :
          Utilisateur â¡ï¸ /auth/register â¡ï¸ Serveur â¡ï¸ Sauvegarde dans BDD ğŸ—„ï¸
          
          2ï¸âƒ£ Login :
          Utilisateur â¡ï¸ /auth/login â¡ï¸ GÃ©nÃ©ration dâ€™un JWT ğŸ”‘
                                  Serveur valide ou refuse les identifiants.
          
          3ï¸âƒ£ Utilisation dâ€™un Token pour RÃ©quÃªtes API :
          Client â¡ï¸ HTTP Header (Authorization: Bearer <JWT>)
          Serveur                    â†• Valide et Autorise/Refuse.
                </pre>
                </div>
            </div>

            <div class="subsection">
                <h3>Quâ€™est-ce quâ€™un JWT (JSON Web Token)â€¯?</h3>
                <p>Un **JWT** est une clÃ© sÃ©curisÃ©e, utilisÃ©e comme preuve dâ€™identitÃ©. Elle se compose de 3 partiesâ€¯:
                </p>

                <ul class="features-list">
                    <li><b>ğŸ“ Header :</b> Contient des informations sur lâ€™algorithme et le type de token (JWT).</li>
                    <li><b>ğŸ“¦ Payload :</b> Transporte des informations sur lâ€™utilisateur (email, rÃ´le, etc.)</li>
                    <li><b>ğŸ–‹ï¸ Signature :</b> VÃ©rifie l'intÃ©gritÃ© du token pour sâ€™assurer quâ€™il nâ€™a pas Ã©tÃ© modifiÃ©.
                    </li>
                </ul>

                <div class="code-section">
                    <h5>ğŸ”— Exemple dâ€™un JWT</h5>
                    <pre><code>
          eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
          .eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
          .SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
                </code></pre>
                </div>

                <div class="concept-card">
                    <h4>Structure</h4>
                    <ul>
                        <li><strong>Header</strong>â€¯:<br>{ "alg": "HS256", "typ": "JWT" }</li>
                        <li><strong>Payload</strong>â€¯:<br>{ "email": "user@example.com", "role": "USER", "exp":
                            1697801937 }</li>
                        <li><strong>Signature</strong> : (signÃ©e avec une clÃ© secrÃ¨te).</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <h3>RÃ©sumÃ© des Ã‰tapes : Authentification par JWT</h3>
                <div class="schema">
                    <pre>
          1ï¸âƒ£ Authentification auprÃ¨s du serveur :
             Utilisateur ğŸ‘‰ `/auth/login` (email + mot de passe)
             Serveur valide et gÃ©nÃ¨re un JWT.
          
          2ï¸âƒ£ RequÃªte API sÃ©curisÃ©e :
             Client ğŸ‘‰ envoie le Header HTTP: Authorization: Bearer <TOKEN>
             Serveur valide le token reÃ§u ğŸ“‘.
          
          3ï¸âƒ£ Expiration :
             Si le token expire, utilisateur doit se reconnecter.
                </pre>
                </div>
                <p>ğŸ”¥ Et voilÃ â€¯! Tu sais maintenant comment fonctionne une authentification sÃ©curisÃ©e par JWT. ğŸ›¡ï¸ On te
                    montre comment lâ€™implÃ©menter dans les chapitres suivants.</p>
                <div class="challenge-card">
                    <h4>ğŸš€ Challenge !</h4>
                    <p>Reproduis ce workflow dans ton projet :</p>
                    <ol>
                        <li>CrÃ©e un endpoint `/auth/register` pour enregistrer les utilisateurs.</li>
                        <li>CrÃ©e un endpoint `/auth/login` qui gÃ©nÃ¨re un JWT aprÃ¨s validation.</li>
                        <li>Configure un filtre JWT pour gÃ©rer l'autorisation sur tes routes sÃ©curisÃ©es.</li>
                    </ol>
                </div>
            </div>
        </section>


        <!-- Introduction Ã  Spring Security -->
        <section id="spring-security-intro" class="section">
            <div class="subsection">
                <h2>9 - Introduction Ã  Spring Security ğŸš€</h2>
                <div class="concept-card">
                    <p>ğŸ¯ **Spring Security** est une bibliothÃ¨que de Spring qui fournit une couche de sÃ©curitÃ© pour
                        gÃ©rer :
                        lâ€™authentification, les autorisations, la protection des routes et bien plus encore.</p>
                    <p>Dans ces prochaines Ã©tapes, tu vas apprendre comment mettre en place lâ€™**authentification par JWT
                        Header** avec Spring Security, tout en dÃ©couvrant ses concepts essentiels.</p>


                    <div class="subsection">
                        <h3>ğŸ›¡ï¸ Spring Security en quelques mots</h3>
                        <p>Câ€™est une **solution de sÃ©curitÃ© robuste**, souvent utilisÃ©e dans les applications
                            Java/Spring
                            pour
                            sÃ©curiser les APIs et contrÃ´ler les accÃ¨s. Voici ce quâ€™il faut retenir avant dâ€™approfondir
                            plus
                            loin
                            :</p>

                        <ul class="features-list">
                            <li>âœ… <strong>DÃ©pendance Maven</strong> : sâ€™active avec un ajout dans le `pom.xml`.</li>
                            <li>âœ… <strong>Gestion des CORS</strong> : intÃ©grÃ©e directement.</li>
                            <li>âœ… <strong>Configuration flexible</strong> : permet de dÃ©finir quelles routes sont
                                protÃ©gÃ©es
                                ou
                                publiques.</li>
                            <li>âœ… <strong>ContrÃ´le par rÃ´le</strong> : restreint lâ€™accÃ¨s aux routes selon les rÃ´les (ex.
                                `ADMIN`, `USER`).</li>
                            <li>âœ… <strong>Couche en amont</strong> : Spring Security agit avant mÃªme que les requÃªtes
                                nâ€™atteignent les contrÃ´leurs.</li>
                            <li>âœ… <strong>SÃ©curisÃ© par dÃ©faut</strong> : toute requÃªte sur une route non dÃ©finie renvoie
                                un
                                statut **403 : Forbidden**.</li>
                        </ul>

                        <div class="notification">
                            ğŸ”— Tu peux explorer la <a href="https://docs.spring.io/spring-security/reference/index.html"
                                rel="noopener" target="_blank">documentation officielle ici</a>.
                        </div>
                    </div>

                </div>

                <div class="subsection">
                    <h3>ğŸ—ºï¸ SchÃ©ma global : Pourquoi utiliser Spring Security ?</h3>
                    <p>Voici un aperÃ§u clair de la maniÃ¨re dont Spring Security sâ€™intÃ¨gre dans ton application :</p>

                    <div class="schema">
                        <h5>âœ¨ Architecture simplifiÃ©e</h5>
                        <pre>
                                          ğŸ›¡ï¸ SPRING SECURITY
           --------------------------------------------------------------------
          |                                                                    |
          |      â¡ï¸ RequÃªte Entrante                                           |
          |                                                                    |
          |      ğŸ” Analyse et Filtrage (CORS, Authentification)               |
          |      ğŸ”“ Validation des Roles                                       |
          |                                                                    |
           --------------------------------------------------------------------
                  â¬‡ï¸                                                                  â¬‡ï¸
                [BloquÃ© : 403 âŒ]                                  [RequÃªte AcceptÃ©e : OK âœ…]
                                      â¬‡ï¸ ContrÃ´leurs
                            (Code mÃ©tier atteint uniquement si autorisÃ©)
                </pre>
                        <p>ğŸ’¡ **En rÃ©sumÃ© :** Spring Security agit comme un filtre qui protÃ¨ge ton application en
                            bloquant
                            les requÃªtes non authentifiÃ©es ou non autorisÃ©es avant qu'elles ne parviennent Ã  tes
                            contrÃ´leurs.</p>
                    </div>
                </div>

                <div class="subsection">
                    <h3>âš™ï¸ Comment configurer Spring Security ?</h3>
                    <div class="concept-card">
                        <p>Pour mettre en place lâ€™authentification par **JWT avec Spring Security**, voici les Ã©tapes
                            globales
                            que tu seras amenÃ©(e) Ã  suivre :</p>

                        <ol class="steps-list">
                            <li><strong>ğŸ“‚ Base de donnÃ©es :</strong> CrÃ©e les tables nÃ©cessaires pour gÃ©rer les
                                utilisateurs.
                            </li>
                            <li><strong>ğŸ§© EntitÃ©s :</strong> CrÃ©e deux entitÃ©s (par exemple : `User` et `Role`).</li>
                            <li><strong>ğŸ’¾ DAO :</strong> CrÃ©e un `UserDao` pour accÃ©der aux donnÃ©es.</li>
                            <li><strong>ğŸ› ï¸ Service :</strong> ImplÃ©mente un service personnalisÃ© pour gÃ©rer les
                                utilisateurs.
                            </li>
                            <li><strong>ğŸ”‘ JWT :</strong> DÃ©veloppe un utilitaire pour gÃ©nÃ©rer et valider les tokens
                                JWT.
                            </li>
                            <li><strong>ğŸ” Filtre JWT :</strong> Ajoute un filtre pour intercepter et valider les
                                requÃªtes
                                entrantes.</li>
                            <li><strong>ğŸ“œ Configuration :</strong> DÃ©finit les routes protÃ©gÃ©es ou non protÃ©gÃ©es.</li>
                            <li><strong>ğŸ“¡ ContrÃ´leur :</strong> CrÃ©e un contrÃ´leur avec des endpoints comme `/register`
                                et
                                `/login`.</li>
                        </ol>

                        <div class="diagram">
                            <img src="images/spring_security_workflow.png" alt="Spring Security Workflow"
                                class="responsive-image">
                            <p>Ce diagramme montre comment les composants se connectent et interagissent grÃ¢ce Ã  Spring
                                Security.</p>
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3>âš–ï¸ Pourquoi et quand utiliser Spring Securityâ€¯?</h3>
                    <div class="concept-card">
                        <p>Voici une liste critique pour savoir **quand choisir Spring Security** :</p>

                        <ul class="pros-and-cons">
                            <li><strong>Utiliser Spring Security si :</strong>
                                <ul>
                                    <li>âœ… Tu cherches une solution complÃ¨te de gestion de lâ€™authentification
                                        (login/logout).
                                    </li>
                                    <li>âœ… Tu dois contrÃ´ler les accÃ¨s (par rÃ´le ou permissions).</li>
                                    <li>âœ… Tu utilises dÃ©jÃ  lâ€™Ã©cosystÃ¨me Spring Boot.</li>
                                    <li>âœ… Tu souhaites sÃ©curiser ton application via des JWT ou Basic Auth.</li>
                                </ul>
                            </li>
                            <li><strong>Ne pas utiliser Spring Security si :</strong>
                                <ul>
                                    <li>âŒ Ton projet est trÃ¨s lÃ©ger (et n'utilise pas Spring Boot).</li>
                                    <li>âŒ Tu recherches une solution trÃ¨s simplifiÃ©e sans authentification avancÃ©e.</li>
                                </ul>
                            </li>
                        </ul>

                        <p><strong>En rÃ©sumÃ© :</strong> Spring Security est idÃ©al lorsquâ€™un haut degrÃ© de sÃ©curitÃ© et de
                            personnalisation est requis, notamment dans des environnements professionnels ou complexes.
                        </p>
                    </div>
                </div>

                <div class="subsection">
                    <h3>ğŸ¯ Ã‰tape suivante : ImplÃ©mentation complÃ¨te</h3>
                    <div class="concept-card">
                        <p>Dans les chapitres suivants, tu apprendras Ã  implÃ©menter chaque Ã©tape, petit Ã  petit :</p>

                        <div class="next-steps-list">
                            <ul>
                                <li>ğŸ‘¨â€ğŸ’» [Base de donnÃ©es, entitÃ©s et DAO](#)</li>
                                <li>ğŸ” [CrÃ©ation du service utilisateur](#)</li>
                                <li>ğŸ”‘ [GÃ©nÃ©ration et validation du JWT](#)</li>
                                <li>âš™ï¸ [Ajout dâ€™un filtre JWT dynamique](#)</li>
                                <li>ğŸ›¡ï¸ [Configuration des routes sÃ©curisÃ©es](#)</li>
                                <li>ğŸ“¡ [Endpoints /register et /login](#)</li>
                            </ul>
                        </div>
                        <p><a href="#next-chapter" class="button">â¡ï¸ Passer au chapitre suivant</a></p>
                    </div>

                </div>
        </section>


        <!-- Ajustement BDD - EntitÃ©s et DAO -->
        <section id="adjust-bdd" class="section">
            <div class="subsection">
                <h3>10 - Ajustement BDD - EntitÃ©s et DAO</h3>
                <div class="concept-card">
                    <i class="fas fa-database"></i>

                    <h4>1. Introduction</h4>
                    <p>ğŸš€ <strong>Objectif :</strong> Mettre Ã  jour la base de donnÃ©es pour gÃ©rer les utilisateurs et
                        implÃ©menter les premiers outils Spring pour la gestion de la sÃ©curitÃ©. Dans cette partie, tu vas
                        :</p>
                    <ul class="features-list">
                        <li>CrÃ©er une table <code>user</code> pour stocker les donnÃ©es des utilisateurs.</li>
                        <li>DÃ©velopper deux entitÃ©s : <code>User</code> et <code>CustomUserDetails</code>.</li>
                        <li>ImplÃ©menter un DAO pour interagir avec la base de donnÃ©es.</li>
                    </ul>

                    <div class="tip-box">
                        <i class="fas fa-lightbulb"></i>
                        <strong>L'astuce Formateur :</strong> Pense toujours Ã  bien structurer ton modÃ¨le de donnÃ©es
                        pour faciliter son utilisation dans toutes les couches de ton application.
                    </div>

                    <h4>2. CrÃ©ation de la table <code>user</code></h4>
                    <p>Commence par ajouter une table <code>user</code> dans la base de donnÃ©es. Cette table stocke les
                        informations de chaque utilisateur.</p>
                    <div class="code-section">
                        <pre><code>
CREATE TABLE IF NOT EXISTS user (
    id INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL
);
                </code></pre>
                    </div>

                    <h5>ğŸ“Š Diagramme simplifiÃ© de la table</h5>
                    <div class="diagram">
                        <pre><code>
+--------+---------+------+------------+
| Field  | Type    | Null | Constraints|
+--------+---------+------+------------+
| id     | INT     | NO   | AUTO_INC   |
| email  | VARCHAR | NO   | UNIQUE     |
| passwd | VARCHAR | NO   |            |
| role   | VARCHAR | NO   |            |
+--------+---------+------+------------+
                </code></pre>
                    </div>

                    <h4>3. Les entitÃ©s</h4>

                    <h5>3.1 EntitÃ© <code>User</code></h5>
                    <p>L'entitÃ© <code>User</code> reprÃ©sente un utilisateur dans ton systÃ¨me. Place-la dans ton package
                        <code>entities</code>.
                    </p>
                    <div class="code-section">
                        <pre><code>
// ReprÃ©sente un utilisateur dans la base de donnÃ©es
public class User {
    private int id;             // Identifiant unique
    private String email;       // Adresse email
    private String password;    // Mot de passe
    private String role;        // RÃ´le (USER / ADMIN)

    public User() {}

    // Constructeurs
    public User(int id, String email, String password, String role) {
        this.id = id;
        this.email = email;
        this.password = password;
        this.role = role;
    }

    // Constructeur sans id (pour la crÃ©ation)
    public User(String email, String password, String role) {
        this.email = email;
        this.password = password;
        this.role = role;
    }

    // Getters et Setters !
}
                </code></pre>
                    </div>

                    <div class="tip-box">
                        <p>âš ï¸ <strong>Important :</strong> Le constructeur vide est <strong>obligatoire</strong>. Cela
                            permet, par exemple, que <code>Jackson</code> dÃ©serialize un JSON en objet Java.</p>
                    </div>

                    <h5>3.2. EntitÃ© <code>CustomUserDetails</code></h5>
                    <p>Cette classe permet de connecter ton entitÃ© <code>User</code> avec Spring Security, en
                        redÃ©finissant ses propriÃ©tÃ©s pour les rendre compatibles.</p>
                    <p>Place-le dans ton package <code>entities</code> :</p>

                    <div class="code-section">
                        <pre><code>
public class CustomUserDetails implements UserDetails {
    private final User user;

    // On "entoure" l'entitÃ© User ici
    public CustomUserDetails(User user) {
        this.user = user;
    }

    // Ajout des rÃ´les au format Spring Security
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(() -> "ROLE_" + user.getRole());
    }

    // Retourne le mot de passe dans le bon format
    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getEmail();
    }

    // MÃ©thodes par dÃ©faut pour les comptes utilisateur
    @Override
    public boolean isAccountNonExpired() { return true; }
    @Override
    public boolean isAccountNonLocked() { return true; }
    @Override
    public boolean isCredentialsNonExpired() { return true; }
    @Override
    public boolean isEnabled() { return true; }
}
                </code></pre>
                    </div>

                    <h4>4. Mise en place du DAO</h4>
                    <p>ImplÃ©mentons un DAO pour interagir avec la table <code>user</code> dans la base de donnÃ©es. Les
                        fonctionnalitÃ©s principales sontâ€¯:</p>
                    <ul class="features-list">
                        <li>CrÃ©er un utilisateur</li>
                        <li>RÃ©cupÃ©rer un utilisateur par email</li>
                        <li>VÃ©rifier si un utilisateur existe via son email</li>
                    </ul>

                    <h5>4.1. Code DAO</h5>
                    <div class="code-section">
                        <pre><code>
@Repository
public class UserDao {
    
    private final JdbcTemplate jdbcTemplate;

    public UserDao(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    private final RowMapper<User> userRowMapper = (rs, _) -> new User(
        rs.getInt("id"),
        rs.getString("email"),
        rs.getString("password"),
        rs.getString("role")
    );

    public User findByEmail(String email) {
        String sql = "SELECT * FROM user WHERE email = ?";
        return jdbcTemplate.query(sql, userRowMapper, email)
                .stream()
                .findFirst()
                .orElseThrow(() -> new UsernameNotFoundException("Utilisateur non trouvÃ©"));
    }

    public boolean save(User user) {
        String sql = "INSERT INTO user (email, password, role) VALUES (?, ?, ?)";
        int rowsAffected = jdbcTemplate.update(sql, user.getEmail(), user.getPassword(), user.getRole());
        return rowsAffected > 0;
    }

    public boolean existsByEmail(String email) {
        String sql = "SELECT COUNT(*) FROM user WHERE email = ?";
        return jdbcTemplate.queryForObject(sql, Integer.class, email) > 0;
    }
}
                </code></pre>
                    </div>

                    <h5>4.2. Flux des mÃ©thodes du DAO</h5>
                    <div class="diagram">
                        <pre><code>
[ findByEmail() ]
       |
       v
+--------------------------+
| SQL Query ("SELECT ...") |
+--------------------------+
       |
User Not Found â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Throw Exception
                </code></pre>
                    </div>

                    <h4>5. Conclusion</h4>
                    <p>ğŸ‰ Superâ€¯! Tu as appris Ã  :</p>
                    <ul class="features-list">
                        <li>CrÃ©er une table SQL</li>
                        <li>DÃ©velopper des entitÃ©s Java pour reprÃ©senter les utilisateurs</li>
                        <li>Configurer ta passerelle entre <code>Spring Security</code> et ta base</li>
                        <li>ImplÃ©menter un DAO pour connecter ton back-end avec ta base de donnÃ©es</li>
                    </ul>

                    <div class="action-callout">
                        <p>â¡ï¸ Passe Ã  l'implÃ©mentation du <code>CustomUserDetailsService</code> dans la prochaine
                            sectionâ€¯!</p>
                    </div>
                </div>
            </div>
        </section>


        <!-- CrÃ©ation du service CustomUserDetails -->
        <section id="custom-user-details-service" class="section">
            <div class="subsection">
                <h3>11 - CrÃ©ation du service CustomUserDetails</h3>
                <div class="concept-card">
                    <i class="fas fa-tools"></i>

                    <h4>1. Introduction</h4>
                    <p>ğŸš€ Dans ce chapitre, tu vas apprendre Ã  intercaler une <strong>couche de service</strong> entre
                        le DAO et Spring Security. Spring Security nÃ©cessite une implÃ©mentation de son interface
                        <code>UserDetailsService</code> pour authentifier les utilisateurs Ã  partir de ta base de
                        donnÃ©es.
                    </p>
                    <p>Voici un rappel du rÃ´le dâ€™une couche de service dans une architecture Backend :</p>

                    <h5>ğŸ“Š SchÃ©ma d'une architecture simplifiÃ©e</h5>
                    <div class="diagram">
                        <pre><code>
+---------------+       +---------------+       +--------------------+
|   Controller  | <---> |    Service    | <---> |     UserDao / BDD  |
+---------------+       +---------------+       +--------------------+
   â†‘ Utilisateur        â†‘ Logique mÃ©tier        â†‘ Interaction directe
   â†‘ Web Request         (Validator, etc.)        (avec la base)
                </code></pre>
                    </div>

                    <p>Cette structure permet dâ€™organiser ton code et de centraliser la logique mÃ©tier (comme iciâ€¯:
                        charger un utilisateur depuis la base et l'injecter dans Spring Security).</p>

                    <h4>2. CrÃ©ation du Service - Classe <code>CustomUserDetailsService</code></h4>
                    <p>Ajoute maintenant une nouvelle classe dans le package <code>service</code> pour implÃ©menter le
                        serviceâ€¯:</p>
                    <div class="code-section">
                        <pre><code>
@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final UserDao userDao;

    // Injection du DAO utilisateur
    public CustomUserDetailsService(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // On rÃ©cupÃ¨re l'utilisateur en BDD via le DAO
        User user = userDao.findByEmail(username);

        // On encapsule cet utilisateur dans CustomUserDetails 
        return new CustomUserDetails(user);
    }
}
                </code></pre>
                    </div>

                    <h5>ğŸ“š Explication du Service en dÃ©tails :</h5>
                    <div class="tip-box">
                        <p>Cette classe joue un rÃ´le essentiel pour connecter Spring Security Ã  ta base de donnÃ©es.
                            Voici ses caractÃ©ristiques principales :</p>
                        <ul class="features-list">
                            <li><strong>Annotation @Service :</strong> Permet Ã  Spring de gÃ©rer cette classe comme un
                                Bean.</li>
                            <li><strong>ImplÃ©mentation de lâ€™interface UserDetailsService :</strong> Interface de Spring
                                Security pour connecter un utilisateur.</li>
                            <li><strong>MÃ©thode obligatoire :</strong> La mÃ©thode <code>loadUserByUsername()</code> est
                                redÃ©finie (Polymorphisme) pour effectuer la logique spÃ©cifique Ã  ton application.</li>
                        </ul>
                    </div>

                    <h5>ğŸ”— SchÃ©ma du processus</h5>
                    <div class="diagram">
                        <pre><code>
Ã‰tapes du Service CustomUserDetails :
-------------------------------------
1. [Spring] Appel Ã  loadUserByUsername()
          â†“
2. [DAO] Recherche de l'utilisateur via email
          â†“
3. [CustomUserDetails] Encapsulation dans la classe Spring-compatible
          â†“
4. Renvoi d'un UserDetails (prÃªt pour Spring Security)
                </code></pre>
                    </div>

                    <h5>ğŸ’¡ Points ClÃ©s Ã  Retenir :</h5>
                    <ul class="features-list">
                        <li>Ce service agit comme une passerelle entre le DAO et Spring Security.</li>
                        <li>La mÃ©thode <code>loadUserByUsername()</code> est appelÃ©e automatiquement par <strong>Spring
                                Security</strong>.</li>
                        <li>Le type de retour attendu est <code>UserDetails</code>.</li>
                        <li>La logique mÃ©tier spÃ©cifique (comme la gestion des exceptions utilisateur) peut Ãªtre
                            centralisÃ©e ici.</li>
                        <li>Ce service tire parti du polymorphisme (concept Java puissant) pour adapter cette mÃ©thode
                            aux besoins mÃ©tier de ton application.</li>
                    </ul>

                    <h4>3. Comment cela fonctionne ?</h4>
                    <p>Voici une vue simplifiÃ©e de la chaÃ®ne de responsabilitÃ©, pour comprendre comment ton service
                        sâ€™intÃ¨gre :</p>
                    <div class="diagram">
                        <pre><code>
+-------------+     +--------------------+     +---------------------------+
| Spring Sec. | --> | CustomUserDetails  | --> | UserDao (Base de donnÃ©es) |
| (Appelle la |     | Service            |     |                           |
| mÃ©thode     |     | (Transforme User ->|     |                           |
| loadUser... |     | CustomUserDetails) |     |                           |
+-------------+     +--------------------+     +---------------------------+
                </code></pre>
                    </div>

                    <h4>4. Code CommentÃ© - Ã‰tape par Ã‰tape</h4>
                    <p>Voici une version plus dÃ©taillÃ©e et commentÃ©e du code du service
                        <code>CustomUserDetailsService</code> :
                    </p>
                    <div class="code-section">
                        <pre><code>
// Annotation pour dÃ©signer cette classe comme un Bean utilisable
@Service  
public class CustomUserDetailsService implements UserDetailsService {

    // DAO injectÃ© automatiquement par Spring via le constructeur
    private final UserDao userDao;

    public CustomUserDetailsService(UserDao userDao) {
        // Assignation du DAO pour gÃ©rer les interactions avec la BDD
        this.userDao = userDao;
    }

    /**
     * MÃ©thode clÃ© appelÃ©e par Spring Security pour charger un utilisateur
     * @param username : Le nom d'utilisateur, ici remplacÃ© par "email"
     * @return UserDetails : Objet que Spring Security comprend
     * @throws UsernameNotFoundException : Si aucun utilisateur trouvÃ©
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // Recherche d'un utilisateur par email dans la base de donnÃ©es via le DAO
        User user = userDao.findByEmail(username);

        if (user == null) {
            // Exception dÃ©clenchÃ©e si aucun utilisateur trouvÃ©
            throw new UsernameNotFoundException("Utilisateur non trouvÃ© avec l'email : " + username);
        }

        // Encapsulation de l'utilisateur dans une classe UserDetails compatible
        return new CustomUserDetails(user);
    }
}
                </code></pre>
                    </div>

                    <h4>5. Conclusion</h4>
                    <p>ğŸ‰ FÃ©licitations ! Tu as maintenant crÃ©Ã© le service <code>CustomUserDetailsService</code>,
                        essentiel pour permettre Ã  Spring Security de charger des utilisateurs depuis ta base de donnÃ©es
                        et de les authentifier.</p>
                    <ul class="features-list">
                        <li><strong>Service CustomUserDetails :</strong> Connecte ton utilisateur stockÃ© en base Ã 
                            Spring Security.</li>
                        <li>MÃ©thode clÃ©â€¯: <code>loadUserByUsername()</code> fournit un <code>UserDetails</code> pour
                            Spring Security.</li>
                        <li>Code basÃ© sur une architecture propre, avec interception via une couche distincte (service).
                        </li>
                    </ul>

                    <div class="action-callout">
                        <p>â¡ï¸ Continue avec la prochaine Ã©tapeâ€¯: [La crÃ©ation du service pour gÃ©nÃ©rer et valider un
                            token](#token-service)</p>
                    </div>
                </div>
            </div>
        </section>


        <!-- CrÃ©ation d'un service pour gÃ©nÃ©rer et valider un token -->
        <section id="jwt-util-service" class="section">
            <div class="subsection">
                <h3>12 - CrÃ©ation dâ€™un service pour gÃ©nÃ©rer et valider un token</h3>
                <div class="concept-card">
                    <i class="fas fa-lock"></i>

                    <h4>1. Introduction</h4>
                    <p>ğŸš€ Dans cette section, tu vas crÃ©er un service utilitaire pour gÃ©rer les <strong>tokens
                            JWT</strong>. Ce service aura deux objectifs principaux :</p>
                    <ul class="features-list">
                        <li>GÃ©nÃ©rer un nouveau token JWT pour lâ€™authentification dâ€™un utilisateur.</li>
                        <li>Valider un token JWT afin de sâ€™assurer que la requÃªte entrante est lÃ©gitime.</li>
                    </ul>

                    <div class="tip-box">
                        <i class="fas fa-info-circle"></i>
                        <p>ğŸ’¡ Les tokens JWT (JSON Web Tokens) sont une mÃ©thode sÃ©curisÃ©e et compacte pour transmettre
                            des informations entre une application et un client.</p>
                    </div>

                    <h4>2. Ajout des dÃ©pendances</h4>
                    <p>Pour utiliser JSON Web Tokens, ajoute les dÃ©pendances nÃ©cessaires dans ton fichier
                        <code>pom.xml</code> :
                    </p>
                    <div class="code-section">
                        <pre><code>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
                </code></pre>
                    </div>
                    <p>ğŸ”„ <strong>AprÃ¨s avoir ajoutÃ© ces dÃ©pendances :</strong> recharge ton projet Maven pour qu'elles
                        soient bien prises en compte.</p>

                    <h4>3. Configuration du fichier <code>application.properties</code></h4>
                    <p>Ajoute les valeurs suivantes au fichier <code>application.properties</code> :</p>
                    <div class="code-section">
                        <pre><code>
jwt.secret=your_secret_key
jwt.expiration=3600000
                </code></pre>
                    </div>
                    <ul class="features-list">
                        <li><code>jwt.secret</code> : La clÃ© secrÃ¨te utilisÃ©e pour signer et valider le token.</li>
                        <li><code>jwt.expiration</code> : DurÃ©e de validitÃ© du token en millisecondes
                            (<code>3600000</code> = 1 heure).</li>
                    </ul>
                    <div class="tip-box">
                        <p>âš ï¸ Cette clÃ© doit Ãªtre secrÃ¨te ! Ajoute-la dans tes <strong>variables
                                dâ€™environnement</strong>.</p>
                    </div>

                    <h4>4. CrÃ©ation de la classe <code>JwtUtil</code></h4>
                    <p>CrÃ©e un package nommÃ© <code>security</code> et ajoute-y une classe <code>JwtUtil</code>. Cette
                        classe contient les mÃ©thodes pour gÃ©nÃ©rer, valider et parser les tokens.</p>

                    <h5>4.1 Initialisation de la clÃ© JWT</h5>
                    <p>DÃ©finis d'abord la clÃ© qui sera utilisÃ©e pour signer et valider les tokens :</p>
                    <div class="code-section">
                        <pre><code>
@Service
public class JwtUtil {
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    @Value("${jwt.expiration}")
    private int jwtExpirationMs;

    private SecretKey key;

    @PostConstruct
    public void init() {
        this.key = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
    }
}
                </code></pre>
                    </div>
                    <ul class="features-list">
                        <li>La clÃ© <code>jwtSecret</code> est injectÃ©e depuis le fichier
                            <code>application.properties</code>.
                        </li>
                        <li>La mÃ©thode <code>@PostConstruct</code> initialise la clÃ© aprÃ¨s que <code>Spring</code> a
                            injectÃ© les valeurs nÃ©cessaires.</li>
                        <li>La mÃ©thode <code>Keys.hmacShaKeyFor()</code> transforme la clÃ© secrÃ¨te en un objet
                            utilisable par JJWT.</li>
                    </ul>

                    <h5>ğŸ’¡ Illustrons la gÃ©nÃ©ration de la clÃ© secrÃ¨te :</h5>
                    <div class="diagram">
                        <pre><code>
+-----------------------+     +------------------------------+
| Key provenant des     | --> | Conversion en tableau de    |
| application.properties|     | bytes (utf-8) via jwtSecret |
+-----------------------+     +------------------------------+
                </code></pre>
                    </div>

                    <h5>4.2 GÃ©nÃ©ration dâ€™un token</h5>
                    <p>Ajoute maintenant une mÃ©thode pour gÃ©nÃ©rer un token JWT :</p>
                    <div class="code-section">
                        <pre><code>
public String generateToken(String email) {
    return Jwts.builder()
            .setSubject(email)
            .setIssuedAt(new Date())
            .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
            .signWith(key, SignatureAlgorithm.HS256)
            .compact();
}
                </code></pre>
                    </div>
                    <ul class="features-list">
                        <li><code>setSubject()</code> : DÃ©finit le champ principal (ici, lâ€™email).</li>
                        <li><code>setIssuedAt()</code> : Date et heure de crÃ©ation du token.</li>
                        <li><code>setExpiration()</code> : Temps avant lâ€™expiration du token.</li>
                        <li><code>signWith()</code> : Signe le token avec la clÃ© secrÃ¨te.</li>
                    </ul>

                    <h5>ğŸ’¡ SchÃ©ma du flux de gÃ©nÃ©ration d'un token :</h5>
                    <div class="diagram">
                        <pre><code>
1. RÃ©cupÃ©ration de l'email
        â†“
2. CrÃ©ation du token
        â†“
3. Signer avec la clÃ©        -->        +------+  JWT (signÃ©)
                </code></pre>
                    </div>

                    <h5>4.3 Extraire lâ€™utilisateur depuis le token</h5>
                    <p>Ajoute une mÃ©thode pour rÃ©cupÃ©rer une information utile (comme lâ€™email) depuis un token :</p>
                    <div class="code-section">
                        <pre><code>
public String getEmailFromToken(String token) {
    return Jwts.parserBuilder()
            .setSigningKey(key).build()
            .parseClaimsJws(token)
            .getBody()
            .getSubject();
}
                </code></pre>
                    </div>
                    <ul class="features-list">
                        <li><code>setSigningKey()</code> : Configure la clÃ© utilisÃ©e pour signer le token.</li>
                        <li><code>parseClaimsJws()</code> : Analyse le payload du token.</li>
                        <li><code>getSubject()</code> : RÃ©cupÃ¨re lâ€™email ou autre champ principal dÃ©fini lors de la
                            gÃ©nÃ©ration du token.</li>
                    </ul>

                    <h5>ğŸ’¡ Vue simplifiÃ©e du traitement dâ€™un token entrant :</h5>
                    <div class="diagram">
                        <pre><code>
+--------+                      +-----------------------------+
| Token  |  ---Verifier-->      | Signature valide (clÃ© JWT) |
+--------+                      +-----------------------------+
          |
           ---> Payloadè§£æ      ---> RÃ©cupÃ©rer des donnÃ©es
                </code></pre>
                    </div>

                    <h5>4.4 Validation dâ€™un token</h5>
                    <p>Enfin, Ã©cris une mÃ©thode pour valider quâ€™un token est bien formatÃ© et signÃ© :</p>
                    <div class="code-section">
                        <pre><code>
public boolean validateJwtToken(String token) {
    try {
        Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);
        return true;
    } catch (Exception e) {
        // Gestion des exceptions "token invalide"
        e.printStackTrace();
        return false;
    }
}
                </code></pre>
                    </div>
                    <p>Les exceptions gÃ©rÃ©es sont :</p>
                    <ul class="features-list">
                        <li><code>ExpiredJwtException</code> : Token expirÃ©.</li>
                        <li><code>MalformedJwtException</code> : Token malformÃ©.</li>
                        <li><code>SecurityException</code> : Mauvaise signature.</li>
                    </ul>

                    <h4>5. Code Final</h4>
                    <p>Ton fichier ressemblant Ã  cela :</p>
                    <div class="code-section">
                        <pre><code>
// [Voir rÃ©sumÃ© final de JwtUtil]
                </code></pre>
                    </div>

                    <h4>6. Conclusion</h4>
                    <p>ğŸ‰ FÃ©licitationsâ€¯! Tu as maintenant :</p>
                    <ul class="features-list">
                        <li>CrÃ©Ã© un service pour manipuler les JWT.</li>
                        <li>AjoutÃ© des mÃ©thodes de gÃ©nÃ©ration, extraction et validation.</li>
                        <li>OrganisÃ© correctement les informations sensibles avec <code>application.properties</code>.
                        </li>
                    </ul>
                    <div class="action-callout">
                        <p>â¡ï¸ Prochaine Ã©tape : Ajouter un <strong>filtre JWT</strong> pour valider les requÃªtes
                            entrantes !</p>
                    </div>
                </div>
            </div>
        </section>


        <!-- CrÃ©ation dâ€™un filtre JWT pour authentifier les requÃªtes entrantes -->
        <section id="jwt-filter" class="section">
            <div class="subsection">
                <h3>6 â€“ CrÃ©ation dâ€™un filtre JWT pour authentifier les requÃªtes entrantes</h3>
                <div class="concept-card">
                    <i class="fas fa-key"></i>

                    <h4>1. Introduction</h4>
                    <p>
                        Tu utilises une authentification basÃ©e sur les headers JWT (JSON Web Token).
                        Chaque requÃªte HTTP envoyÃ©e Ã  ton API devra donc Ãªtre analysÃ©eâ€¯:
                        vÃ©rifier si elle contient un **JWT** valide et authentifier son utilisateur si c'est le cas.
                        ğŸ›¡ï¸ C'est ici que ton filtre JWT intervient.
                        Il fonctionne en amont de Spring Security et des contrÃ´leurs, comme une premiÃ¨re barriÃ¨re
                        ğŸ¯.
                    </p>

                    <h4>2. Ajout du Filtre JWT</h4>
                    <p>
                        CrÃ©e une classe <code>JwtFilter</code> dans le package <code>security</code> avec le code
                        suivantâ€¯:
                    </p>
                    <div class="code-section">
                        <pre><code>
  @Component
  public class JwtFilter extends OncePerRequestFilter {
  
      private final JwtUtil jwtUtil;
      private final CustomUserDetailsService userDetailsService;
  
      public JwtFilter(JwtUtil jwtUtil, CustomUserDetailsService userDetailsService) {
          this.jwtUtil = jwtUtil;
          this.userDetailsService = userDetailsService;
      }
  
      @Override
      protected void doFilterInternal(HttpServletRequest request, 
                                      HttpServletResponse response, 
                                      FilterChain chain)
              throws ServletException, IOException {
          try {
              String jwt = parseJwt(request);
              if (jwt != null && jwtUtil.validateJwtToken(jwt)) {
                  String username = jwtUtil.getEmailFromToken(jwt);
                  UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                  UsernamePasswordAuthenticationToken authentication =
                          new UsernamePasswordAuthenticationToken(
                                  userDetails, 
                                  null, 
                                  userDetails.getAuthorities()
                          );
                  authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                  SecurityContextHolder.getContext().setAuthentication(authentication);
              }
          } catch (Exception e) {
              System.out.println("Cannot set user authentication: " + e);
          }
          chain.doFilter(request, response);
      }
  
      private String parseJwt(HttpServletRequest request) {
          String headerAuth = request.getHeader("Authorization");
          if (headerAuth != null && headerAuth.startsWith("Bearer ")) {
              return headerAuth.substring(7);
          }
          return null;
      }
  }
          </code></pre>
                    </div>

                    <h5>Observations importantes :</h5>
                    <ul class="features-list">
                        <li><strong>@Component</strong> indique Ã  Spring que cette classe est un Bean injectable.</li>
                        <li>La classe <code>JwtFilter</code> hÃ©rite de <code>OncePerRequestFilter</code>,
                            une classe existante de Spring qui permet dâ€™effectuer une action unique par requÃªte.</li>
                        <li>Le filtre implÃ©mente la mÃ©thode <code>doFilterInternal()</code>, qui agit sur chaque
                            requÃªte.</li>
                    </ul>

                    <h4>3. La mÃ©thode utilitaire <code>parseJwt</code></h4>
                    <p>
                        Cette mÃ©thode privÃ©e est utilisÃ©e pour analyser et extraire le token JWT depuis
                        le header <code>Authorization</code> de la requÃªte entranteâ€¯:
                    </p>
                    <div class="code-section">
                        <pre><code>
  private String parseJwt(HttpServletRequest request) {
      String headerAuth = request.getHeader("Authorization");
      if (headerAuth != null && headerAuth.startsWith("Bearer ")) {
          return headerAuth.substring(7); // Retire "Bearer "
      }
      return null;
  }
          </code></pre>
                    </div>
                    <p>Son fonctionnementâ€¯:</p>
                    <ul class="features-list">
                        <li>Elle rÃ©cupÃ¨re le header <code>Authorization</code> de la requÃªte.</li>
                        <li>Elle vÃ©rifie si le header n'est pas <code>null</code> et commence par <code>Bearer</code>.
                        </li>
                        <li>Elle extrait uniquement le token en supprimant le prÃ©fixe <code>Bearer</code>.</li>
                        <li>Si le header est absent ou mal formÃ©, elle retourne <code>null</code>.</li>
                    </ul>

                    <h4>4. La mÃ©thode <code>doFilterInternal()</code></h4>
                    <p>
                        Analyse dÃ©taillÃ©e de l'implÃ©mentation de <code>doFilterInternal()</code> pour sÃ©curiser
                        l'accÃ¨sâ€¯:
                    </p>
                    <div class="code-section">
                        <pre><code>
  @Override
  protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain chain)
          throws ServletException, IOException {
      try {
          String jwt = parseJwt(request);
          if (jwt != null && jwtUtil.validateJwtToken(jwt)) {
              String username = jwtUtil.getEmailFromToken(jwt);
              UserDetails userDetails = userDetailsService.loadUserByUsername(username);
              UsernamePasswordAuthenticationToken authentication =
                      new UsernamePasswordAuthenticationToken(
                              userDetails, 
                              null, 
                              userDetails.getAuthorities());
              authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
              SecurityContextHolder.getContext().setAuthentication(authentication);
          }
      } catch (Exception e) {
          System.out.println("Cannot set user authentication: " + e);
      }
      chain.doFilter(request, response); // Continue dans la chaine de filtres
  }
          </code></pre>
                    </div>
                    <p>Voici le rÃ´le de ce blocâ€¯:</p>
                    <ul class="features-list">
                        <li>RÃ©cupÃ¨re le JWT via la mÃ©thode utilitaire <code>parseJwt()</code>.</li>
                        <li>VÃ©rifie si le tokenâ€¯:
                            <ul class="prerequis-list">
                                <li>n'est pas <code>null</code>â€¯;</li>
                                <li>est valide via <code>jwtUtil.validateJwtToken()</code>.</li>
                            </ul>
                        </li>
                        <li>Charge l'utilisateur correspondant dans la base via <code>CustomUserDetailsService</code>.
                        </li>
                        <li>CrÃ©e un objet d'authentification protÃ©gÃ© <code>UsernamePasswordAuthenticationToken</code>.
                        </li>
                        <li>Met Ã  jour le <code>SecurityContextHolder</code>, essentiel pour Spring Security.</li>
                        <li>Termine en appelant <code>chain.doFilter(request, response)</code>, pour poursuivre la
                            chaÃ®ne de filtres.</li>
                    </ul>

                    <h4>5. Comprendre le comportement Ã  diffÃ©rents cas</h4>
                    <p>Voici ce qu'il se passe selon diffÃ©rents scÃ©nariosâ€¯:</p>
                    <ul class="features-list">
                        <li><strong>JWT valideâ€¯:</strong> Spring Security met Ã  jour le contexte grÃ¢ce au
                            <code>SecurityContextHolder</code>.
                        </li>
                        <li><strong>Pas de JWTâ€¯:</strong> La requÃªte continue. Cependant, l'utilisateur ne sera pas
                            authentifiÃ©.</li>
                        <li><strong>JWT invalideâ€¯:</strong> Une exception est levÃ©e et gÃ©rÃ©e, la requÃªte continue sans
                            authentification.</li>
                    </ul>

                    <h4>6. Diagramme simplifiÃ© ğŸ›¡ï¸</h4>
                    <div class="code-section">
                        <pre><code>
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚         HttpServletRequest    â”‚
  â”‚                               â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
  â”‚  â”‚   JwtFilter (Custom)  â”‚    â”‚
  â”‚  â”‚                       â”‚    â”‚
  â”‚  â”‚  âœ“ Analyse le JWT     â”‚    â”‚
  â”‚  â”‚  âœ“ Authentifie l'user â”‚    â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
  â”‚                               â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
  â”‚  â”‚    Spring Security     â”‚    â”‚
  â”‚  â”‚                       â”‚    â”‚
  â”‚  â”‚  Gestion auth + roles â”‚    â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
  â”‚                               â”‚
  â”‚      REST Controller          â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          </code></pre>
                    </div>

                    <h4>7. Points ClÃ©s Ã  Retenir</h4>
                    <ul class="features-list">
                        <li>Le <code>JwtFilter</code> est un gestionnaire de requÃªtes HTTP en **amont de Spring
                            Security**.</li>
                        <li>Il vÃ©rifie la prÃ©sence dâ€™un token JWT, sa validitÃ© et charge lâ€™utilisateur associÃ©.</li>
                        <li>Il prÃ©pare le contexte d'authentification de Spring Security sans interrompre les requÃªtes
                            entrantes.</li>
                        <li>Le systÃ¨me reste robuste grÃ¢ce Ã  la gestion des erreurs locale.</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- SÃ©curiser les routes de ton API -->
        <section id="securiser-routes" class="section">
            <div class="subsection">
                <h3>7 â€“ SÃ©curiser les routes de ton API</h3>
                <div class="concept-card">
                    <i class="fas fa-shield-alt"></i>

                    <h4>1. Introduction</h4>
                    <p>
                        Ã€ ce stade, tu as conÃ§u un filtre personnalisÃ©e (<code>JwtFilter</code>) qui
                        permet de valider un utilisateur grÃ¢ce au token JWT passÃ© en requÃªte.
                        DÃ©sormais, tu vas configurer Spring Security et dÃ©finir des rÃ¨gles afin
                        de **sÃ©curiser les routes** de ton API.
                    </p>

                    <h4>2. CrÃ©ation de la classe <code>SecurityConfig</code></h4>
                    <p>
                        Tout commence par la crÃ©ation dâ€™une classe dÃ©diÃ©e Ã  la configuration de
                        la sÃ©curitÃ©â€¯:
                        <code>SecurityConfig</code>. Voici Ã  quoi elle ressembleâ€¯:
                    </p>
                    <div class="code-section">
                        <pre><code>
  @Configuration
  @EnableWebSecurity
  public class SecurityConfig {
  
      private final JwtFilter jwtFilter;
      private final CustomUserDetailsService userDetailsService;
  
      // Injection des dÃ©pendances
      public SecurityConfig(JwtFilter jwtFilter, 
                            CustomUserDetailsService userDetailsService) {
          this.jwtFilter = jwtFilter;
          this.userDetailsService = userDetailsService;
      }
  }
          </code></pre>
                    </div>

                    <ul class="features-list">
                        <li><strong>@Configuration</strong> indique que câ€™est une classe de configuration Spring.</li>
                        <li><strong>@EnableWebSecurity</strong> dÃ©sactive la config sÃ©curitÃ© par dÃ©faut.</li>
                        <li>Ajout des beans nÃ©cessairesâ€¯: <code>JwtFilter</code> et
                            <code>CustomUserDetailsService</code>.
                        </li>
                    </ul>

                    <h4>3. Le Bean <code>SecurityFilterChain</code></h4>
                    <p>
                        Ce Bean permet de dÃ©finir la <strong>protection des routes</strong>. Ajoute cette mÃ©thodeâ€¯:
                    </p>
                    <div class="code-section">
                        <pre><code>
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
      http
              .csrf(csrf -> csrf.disable())
              .cors(Customizer.withDefaults())
              .sessionManagement(sessionManagement ->
                      sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
              )
              .authorizeHttpRequests(authorizeRequests ->
                      authorizeRequests
                              .requestMatchers("/auth/**", "/test/all").permitAll()
                              .requestMatchers("/user/**").hasRole("USER")
                              .requestMatchers("/admin/**").hasRole("ADMIN")
                              .anyRequest().authenticated()
              );
      http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
      return http.build();
  }
          </code></pre>
                    </div>

                    <h5>Points importants du code :</h5>
                    <ul class="features-list">
                        <li>DÃ©sactivation du **CSRF**, car les JWT sont basÃ©s sur des headers (pas de cookies).</li>
                        <li>Activation du **CORS** avec les paramÃ¨tres par dÃ©faut.</li>
                        <li>DÃ©claration d'une gestion de session <code>STATELESS</code>.</li>
                        <li>Organisation des routesâ€¯:
                            <ul class="prerequis-list">
                                <li><strong>Routes publiquesâ€¯:</strong> <code>permitAll()</code></li>
                                <li><strong>Routes protÃ©gÃ©esâ€¯:</strong> en fonction des rÃ´les avec
                                    <code>hasRole()</code>
                                </li>
                                <li><strong>Autres routesâ€¯:</strong> doivent Ãªtre authentifiÃ©es.</li>
                            </ul>
                        </li>
                        <li>Ajout du filtre personnalisÃ© <code>JwtFilter</code> avant le filtre de Spring Security.</li>
                    </ul>

                    <h4>4. Le Bean <code>AuthenticationProvider</code></h4>
                    <p>
                        Lâ€™<code>AuthenticationProvider</code> permet de gÃ©rer lâ€™authentification via des
                        <strong>DAO</strong> (interaction avec la BDD). Voici comment ajouter ce Beanâ€¯:
                    </p>
                    <div class="code-section">
                        <pre><code>
  @Bean
  public AuthenticationProvider authenticationProvider() {
      DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
      provider.setUserDetailsService(userDetailsService);
      provider.setPasswordEncoder(new BCryptPasswordEncoder());
      return provider;
  }
          </code></pre>
                    </div>
                    <p>Explications :</p>
                    <ul class="features-list">
                        <li>Utilisation dâ€™un <code>DaoAuthenticationProvider</code> pour les BDD SQL classiques.</li>
                        <li>ImplÃ©mentation du service de recherches en base <code>CustomUserDetailsService</code>
                            prÃ©cÃ©demment crÃ©Ã©.</li>
                        <li>Hachage sÃ©curisÃ© des mots de passe avec **BCrypt** grÃ¢ce au <code>PasswordEncoder</code>.
                        </li>
                    </ul>

                    <h4>5. Le Bean <code>AuthenticationManager</code></h4>
                    <p>
                        Ce Bean enregistre le <code>AuthenticationProvider</code> et sera utilisÃ© pour valider
                        les utilisateurs avant de gÃ©nÃ©rer des JWT.
                    </p>
                    <div class="code-section">
                        <pre><code>
  @Bean
  public AuthenticationManager authenticationManager(
          AuthenticationConfiguration authenticationConfiguration
  ) throws Exception {
      return authenticationConfiguration.getAuthenticationManager();
  }
          </code></pre>
                    </div>

                    <h4>6. Le Bean <code>PasswordEncoder</code></h4>
                    <p>
                        Aucune API sÃ©rieuse nâ€™enregistre un mot de passe en texte clairâ€¯!
                        Enregistre cet encodeur pour hacher les mots de passeâ€¯:
                    </p>
                    <div class="code-section">
                        <pre><code>
  @Bean
  public PasswordEncoder passwordEncoder() {
      return new BCryptPasswordEncoder();
  }
          </code></pre>
                    </div>

                    <h4>7. GÃ©rer les CORS</h4>
                    <p>
                        Si ton application utilise les CORS, voici le Bean Ã  ajouter pour personnaliser ces rÃ¨gle :
                    </p>
                    <div class="code-section">
                        <pre><code>
  @Bean
  CorsConfigurationSource corsConfigurationSource() {
      CorsConfiguration configuration = new CorsConfiguration();
      configuration.setAllowedOriginPatterns(List.of("localhost:3000"));
      configuration.setAllowedMethods(Arrays.asList("HEAD", "GET", "POST", "PUT", "DELETE", "PATCH"));
      configuration.setAllowCredentials(true);
      configuration.setAllowedHeaders(Arrays.asList("Authorization", "Cache-Control", "Content-Type"));
      final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
      source.registerCorsConfiguration("/**", configuration);
      return source;
  }
          </code></pre>
                    </div>

                    <h4>8. RÃ©sumÃ© SchÃ©matique</h4>
                    <div class="code-section">
                        <pre><code>
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚       SecurityConfig          â”‚
  â”‚                               â”‚
  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
  â”‚ â”‚ Beans: SÃ©curitÃ© API        â”‚ â”‚
  â”‚ â”‚                           â”‚ â”‚
  â”‚ â”‚ - SecurityFilterChain     â”‚ â”‚
  â”‚ â”‚ - AuthenticationProvider  â”‚ â”‚
  â”‚ â”‚ - AuthenticationManager   â”‚ â”‚
  â”‚ â”‚ - PasswordEncoder         â”‚ â”‚
  â”‚ â”‚                           â”‚ â”‚
  â”‚ â”‚ CORS Management           â”‚ â”‚
  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
  â”‚                               â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          </code></pre>
                    </div>

                    <h4>9. Points ClÃ©s Ã  Retenir</h4>
                    <ul class="features-list">
                        <li>Spring Security centralise la gestion des routes dans <code>SecurityConfig</code>.</li>
                        <li>Les Beans Ã©tablissent les basesâ€¯:
                            <code>SecurityFilterChain</code>, <code>AuthenticationProvider</code>,
                            <code>PasswordEncoder</code>.
                        </li>
                        <li>Les JWT permettent une gestion stateless, adaptÃ©e aux API modernes.</li>
                        <li>Les rÃ¨gles des routes sâ€™Ã©crivent **de la plus permissive Ã  la plus restrictive**.</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Endpoints dâ€™authentification -->
        <section id="auth-endpoints" class="section">
            <div class="subsection">
                <h3>8 â€“ Endpoints dâ€™authentification</h3>
                <div class="concept-card">
                    <i class="fas fa-unlock-alt"></i>

                    <h4>1. Introduction</h4>
                    <p>
                        Jusquâ€™ici, tu as prÃ©parÃ© toute lâ€™infrastructure pour gÃ©rer lâ€™authentification via JWT.
                        Il est maintenant temps de crÃ©er les endpoints nÃ©cessairesâ€¯: ğŸ˜
                    </p>
                    <ul class="features-list">
                        <li><strong>POST /register :</strong> Permet Ã  un utilisateur de crÃ©er un compte.</li>
                        <li><strong>POST /login :</strong> Permet Ã  un utilisateur de se connecter et de recevoir un
                            token JWT.</li>
                    </ul>

                    <h4>2. Le Controller : <code>AuthController</code></h4>
                    <p>
                        Dans le package <code>controllers</code>, crÃ©e une nouvelle classe <code>AuthController</code>
                        pour gÃ©rer ces endpoints.
                        Voici la base :
                    </p>
                    <div class="code-section">
                        <pre><code>
  @RestController
  @RequestMapping("/auth")
  public class AuthController {
      private final AuthenticationManager authenticationManager;
      private final UserDao userDao;
      private final PasswordEncoder encoder;
      private final JwtUtil jwtUtils;
  
      public AuthController(AuthenticationManager authenticationManager, 
                            UserDao userDao, 
                            PasswordEncoder encoder, 
                            JwtUtil jwtUtils) {
          this.authenticationManager = authenticationManager;
          this.userDao = userDao;
          this.encoder = encoder;
          this.jwtUtils = jwtUtils;
      }
  }
          </code></pre>
                    </div>
                    <p>
                        Ce controller est annotÃ© comme Ã  ton habitude avec <code>@RestController</code> (Web API) et
                        <code>@RequestMapping("/auth")</code>. Les dÃ©pendances nÃ©cessaires sont injectÃ©es dans le
                        constructeurâ€¯:
                    </p>
                    <ul class="features-list">
                        <li><code>AuthenticationManager</code> pour gÃ©rer lâ€™authentification.</li>
                        <li><code>UserDao</code> pour interagir avec la BDD utilisateurs.</li>
                        <li><code>PasswordEncoder</code> pour encoder les mots de passe.</li>
                        <li><code>JwtUtil</code> pour la gÃ©nÃ©ration des tokens JWT.</li>
                    </ul>

                    <h4>3. Le Endpoint <code>POST /register</code></h4>
                    <p>
                        Le premier endpoint permet de crÃ©er un utilisateur et de lâ€™enregistrer en BDD. Voici la mÃ©thode
                        complÃ¨teâ€¯:
                    </p>
                    <div class="code-section">
                        <pre><code>
  @PostMapping("/register")
  public ResponseEntity<String> registerUser(@RequestBody User user) {
      boolean alreadyExists = userDao.existsByEmail(user.getEmail());
      if (alreadyExists) {
          return ResponseEntity.badRequest()
                               .body("Error: Email is already in use!");
      }
      User newUser = new User(
              user.getEmail(),
              encoder.encode(user.getPassword()),
              "USER"
      );
      boolean isUserSaved = userDao.save(newUser);
      if (isUserSaved) {
          return ResponseEntity.ok("User registered successfully!");
      } else {
          return ResponseEntity.badRequest()
                               .body("Error: User registration failed!");
      }
  }
          </code></pre>
                    </div>
                    <p>Explications :</p>
                    <ul class="features-list">
                        <li>VÃ©rifie si un utilisateur existe dÃ©jÃ  avec lâ€™email donnÃ© (via
                            <code>userDao.existsByEmail()</code>).
                        </li>
                        <li>Si lâ€™utilisateur existe, retourne une erreur 400 au client avec un message clair.</li>
                        <li>Si ce nâ€™est pas le casâ€¯:
                            <ul>
                                <li>Un nouvel utilisateur est crÃ©Ã© avec son email et son mot de passe encodÃ©.</li>
                                <li>Par dÃ©faut, le rÃ´le "USER" est attribuÃ©.</li>
                                <li>La sauvegarde en BDD est effectuÃ©e via <code>userDao.save()</code>.</li>
                                <li>Selon le rÃ©sultat, retourne une rÃ©ponse de succÃ¨s ou dâ€™Ã©chec au client.</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>4. Le Endpoint <code>POST /login</code></h4>
                    <p>
                        Le second endpoint gÃ¨re lâ€™authentification. Il prend un email et un mot de passe, et retourne un
                        JWT si tout est correctâ€¯:
                    </p>
                    <div class="code-section">
                        <pre><code>
  @PostMapping("/login")
  public String authenticateUser(@RequestBody User user) {
      Authentication authentication = authenticationManager.authenticate(
              new UsernamePasswordAuthenticationToken(
                      user.getEmail(),
                      user.getPassword()
              )
      );
      UserDetails userDetails = (UserDetails) authentication.getPrincipal();
      return jwtUtils.generateToken(userDetails.getUsername());
  }
          </code></pre>
                    </div>
                    <p>Voici ce que fait ce code :</p>
                    <ul class="features-list">
                        <li>CrÃ©e un <code>UsernamePasswordAuthenticationToken</code> avec lâ€™email et le mot de passe
                            fournis.</li>
                        <li>Utilise <code>authenticationManager</code> pour vÃ©rifier les credentials et renvoyer lâ€™objet
                            Authentication.</li>
                        <li>RÃ©cupÃ¨re les dÃ©tails AuthentifiÃ©s de lâ€™utilisateur via
                            <code>authentication.getPrincipal()</code>.
                        </li>
                        <li>GÃ©nÃ¨re un JWT basÃ© sur lâ€™email de lâ€™utilisateur grÃ¢ce Ã 
                            <code>jwtUtils.generateToken()</code>.
                        </li>
                        <li>Retourne ce JWT au client, qu'il utilisera pour ses futures requÃªtes.</li>
                    </ul>

                    <h4>5. Gestion des exceptions</h4>
                    <p>
                        La mÃ©thode <code>authenticate()</code> peut lever une exception en cas dâ€™Ã©chec, comme
                        <code>BadCredentialsException</code>. Pour Ã©viter un retour brut dâ€™erreur au client, ajoute
                        cette mÃ©thode
                        dans ton <code>GlobalExceptionHandler</code> :
                    </p>
                    <div class="code-section">
                        <pre><code>
  @ExceptionHandler(BadCredentialsException.class)
  public ResponseEntity<String> handleBadCredentialsException(BadCredentialsException ex) {
      return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                           .body("Error: Invalid email/password!");
  }
          </code></pre>
                    </div>
                    <p>
                        Ainsi, si un utilisateur entre des identifiants incorrects, il recevra une rÃ©ponse
                        claire avec un code 401 (non autorisÃ©).
                    </p>

                    <h4>6. Diagramme explicatif ğŸš€</h4>
                    <div class="code-section">
                        <pre><code>
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚         AuthController        â”‚
  â”‚                               â”‚
  â”‚  POST /register               â”‚â”€â”€â”€â”€â–º User enregistrÃ© ou erreur
  â”‚  POST /login                  â”‚â”€â”€â”€â”€â–º JWT gÃ©nÃ©rÃ© ou erreur
  â”‚                               â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
        \_ Gestion des exceptions globales
             BadCredentialsException
          </code></pre>
                    </div>

                    <h4>7. Points ClÃ©s Ã  Retenir</h4>
                    <ul class="features-list">
                        <li>Le controller <code>AuthController</code> est central pour gÃ©rer la crÃ©ation des comptes et
                            les connexions.</li>
                        <li>Le registre utilisateur inclut une vÃ©rification dâ€™unicitÃ© de lâ€™email,
                            et encode le mot de passe avant sauvegarde.</li>
                        <li>Le login authentifie lâ€™utilisateur et retourne un JWT.</li>
                        <li>Les exceptions comme <code>BadCredentialsException</code> sont gÃ©rÃ©es dans le
                            <code>GlobalExceptionHandler</code>.
                        </li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Pratique -->
        <section id="pratique" class="section">
            <div class="concept-card">
                <div class="subsection">
                    <h2> - Mise en Pratique</h2>

                    <div class="subsection">
                        <h3>1. CrÃ©ation d'un projet</h3>
                        <div class="concept-card">
                            <div class="code-example">
                                <pre><code>
<!-- Utilisation de Spring Initializr -->
https://start.spring.io/
- Choisir Maven/Gradle
- Choisir Java 8+
- Ajouter les dÃ©pendances:
  * Spring Web
  * Spring Data JPA
  * H2 Database
            </code></pre>
                                <button class="copy-btn">Copier</button>
                            </div>
                        </div>
                    </div>


                    <div class="subsection">
                        <h3>2. Structure du projet</h3>
                        <div class="concept-card">
                            <div class="code-example">
                                <pre><code>
projet-demo/
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ main/
    â”‚   â”‚   â”œâ”€â”€ java/
    â”‚   â”‚   â”‚   â””â”€â”€ com/example/demo/
    â”‚   â”‚   â”‚       â”œâ”€â”€ DemoApplication.java
    â”‚   â”‚   â”‚       â”œâ”€â”€ controllers/
    â”‚   â”‚   â”‚       â”œâ”€â”€ models/
    â”‚   â”‚   â”‚       â”œâ”€â”€ repositories/
    â”‚   â”‚   â”‚       â””â”€â”€ services/
    â”‚   â”‚   â””â”€â”€ resources/
    â”‚   â”‚       â””â”€â”€ application.properties
    â”‚   â””â”€â”€ test/
    â””â”€â”€ pom.xml
            </code></pre>
                                <button class="copy-btn">Copier</button>
                            </div>
                        </div>
                    </div>


                    <div class="subsection">
                        <h3>3. Application Simple</h3>
                        <div class="concept-card">
                            <div class="code-example">
                                <pre><code>
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}

@RestController
@RequestMapping("/api")
public class HelloController {
    @GetMapping("/hello")
    public String hello() {
        return "Hello Spring Boot!";
    }
}
            </code></pre>
                                <button class="copy-btn">Copier</button>
                            </div>
                        </div>
                    </div>


                    <div class="subsection">
                        <h3>4. Configuration</h3>
                        <div class="concept-card">
                            <div class="code-example">
                                <pre><code>
# application.properties
server.port=8080
spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
            </code></pre>
                                <button class="copy-btn">Copier</button>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </section>


        <!-- Concepts -->
        <section id="concepts" class="section">
            <h2>Concepts ClÃ©s</h2>
            <div class="concepts-grid">
                <div class="concept-card">
                    <i class="fas fa-cogs"></i>
                    <h3>Auto-configuration</h3>
                    <p>Spring Boot configure automatiquement votre application en fonction des
                        dÃ©pendances
                        ajoutÃ©es.
                    </p>
                    <ul>
                        <li>Configuration conditionnelle</li>
                        <li>DÃ©tection automatique</li>
                        <li>Configuration par dÃ©faut</li>
                    </ul>
                </div>

                <div class="concept-card">
                    <i class="fas fa-box"></i>
                    <h3>Spring Boot Starters</h3>
                    <p>DÃ©pendances prÃ©configurÃ©es pour diffÃ©rents scÃ©narios.</p>
                    <ul>
                        <li>spring-boot-starter-web</li>
                        <li>spring-boot-starter-data-jpa</li>
                        <li>spring-boot-starter-test</li>
                        <li>spring-boot-starter-security</li>
                    </ul>
                </div>

                <div class="concept-card">
                    <i class="fas fa-server"></i>
                    <h3>Serveur EmbarquÃ©</h3>
                    <p>Serveur d'application intÃ©grÃ©.</p>
                    <ul>
                        <li>Tomcat par dÃ©faut</li>
                        <li>Jetty en alternative</li>
                        <li>Undertow disponible</li>
                    </ul>
                </div>

                <div class="concept-card">
                    <i class="fas fa-shield-alt"></i>
                    <h3>Spring Security</h3>
                    <p>SÃ©curitÃ© et authentification.</p>
                    <ul>
                        <li>Authentification</li>
                        <li>Autorisation</li>
                        <li>Protection CSRF</li>
                    </ul>
                </div>
            </div>
        </section>


        <!-- Les codes d'Ã‰tat HTTP -->
        <section id="http-errors" class="section">
            <div class="subsection">
                <h3>Comprendre les Codes d'Ã‰tat HTTP</h3>
                <div class="concept-card">
                    <i class="fas fa-exclamation-circle"></i>

                    <h4>1. Codes 1XX - Information</h4>
                    <div class="code-section">
                        <pre><code>
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         Codes 1XX                   â”‚
        â”‚                                     â”‚
        â”‚ 100 â†’ Continue                      â”‚
        â”‚ 101 â†’ Switching Protocols           â”‚
        â”‚ 102 â†’ Processing                    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Client          Serveur
           â”‚    Request    â”‚
           â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
           â”‚              â”‚
           â”‚     100      â”‚
           â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
           â”‚   Continue   â”‚
                        </code></pre>
                    </div>
                    <p>Les codes 1XX indiquent une rÃ©ponse provisoire. Le client doit attendre la
                        rÃ©ponse
                        finale.</p>

                    <h4>2. Codes 2XX - SuccÃ¨s</h4>
                    <div class="code-section">
                        <pre><code>
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         Codes 2XX                   â”‚
        â”‚                                     â”‚
        â”‚ 200 â†’ OK                           â”‚
        â”‚ 201 â†’ Created                      â”‚
        â”‚ 202 â†’ Accepted                     â”‚
        â”‚ 204 â†’ No Content                   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Client          Serveur
           â”‚    Request    â”‚
           â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
           â”‚              â”‚
           â”‚     200      â”‚
           â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
           â”‚     OK       â”‚
                        </code></pre>
                    </div>
                    <p>Les codes 2XX indiquent que la requÃªte a Ã©tÃ© traitÃ©e avec succÃ¨s.</p>

                    <h4>3. Codes 3XX - Redirection</h4>
                    <div class="code-section">
                        <pre><code>
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         Codes 3XX                   â”‚
        â”‚                                     â”‚
        â”‚ 301 â†’ Moved Permanently            â”‚
        â”‚ 302 â†’ Found (Temporary Redirect)   â”‚
        â”‚ 304 â†’ Not Modified                 â”‚
        â”‚ 307 â†’ Temporary Redirect           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Client          Serveur
           â”‚    Request    â”‚
           â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
           â”‚              â”‚
           â”‚     301      â”‚
           â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
           â”‚   Location   â”‚
           â”‚  /new-url    â”‚
                        </code></pre>
                    </div>
                    <p>Les codes 3XX indiquent que le client doit effectuer une action supplÃ©mentaire.
                    </p>

                    <h4>4. Codes 4XX - Erreur Client</h4>
                    <div class="code-section">
                        <pre><code>
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         Codes 4XX                   â”‚
        â”‚                                     â”‚
        â”‚ 400 â†’ Bad Request                  â”‚
        â”‚ 401 â†’ Unauthorized                 â”‚
        â”‚ 403 â†’ Forbidden                    â”‚
        â”‚ 404 â†’ Not Found                    â”‚
        â”‚ 405 â†’ Method Not Allowed           â”‚
        â”‚ 409 â†’ Conflict                     â”‚
        â”‚ 429 â†’ Too Many Requests            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Client          Serveur
           â”‚   Bad Request â”‚
           â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
           â”‚              â”‚
           â”‚     400      â”‚
           â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
           â”‚  Error msg   â”‚
                        </code></pre>
                    </div>
                    <p>Les codes 4XX indiquent une erreur de la part du client.</p>

                    <h4>5. Codes 5XX - Erreur Serveur</h4>
                    <div class="code-section">
                        <pre><code>
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         Codes 5XX                   â”‚
        â”‚                                     â”‚
        â”‚ 500 â†’ Internal Server Error        â”‚
        â”‚ 501 â†’ Not Implemented             â”‚
        â”‚ 502 â†’ Bad Gateway                 â”‚
        â”‚ 503 â†’ Service Unavailable         â”‚
        â”‚ 504 â†’ Gateway Timeout             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Client          Serveur
           â”‚    Request    â”‚
           â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
           â”‚              â”‚ âš¡ Erreur
           â”‚     500      â”‚
           â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
           â”‚  Error msg   â”‚
                        </code></pre>
                    </div>
                    <p>Les codes 5XX indiquent une erreur de la part du serveur.</p>

                    <h4>RÃ©sumÃ© des Codes les Plus Courants</h4>
                    <ul class="features-list">
                        <li>200 : SuccÃ¨s - La requÃªte a Ã©tÃ© traitÃ©e avec succÃ¨s</li>
                        <li>201 : Created - Ressource crÃ©Ã©e avec succÃ¨s</li>
                        <li>400 : Bad Request - RequÃªte mal formÃ©e</li>
                        <li>401 : Unauthorized - Authentification nÃ©cessaire</li>
                        <li>403 : Forbidden - AccÃ¨s interdit</li>
                        <li>404 : Not Found - Ressource non trouvÃ©e</li>
                        <li>500 : Internal Server Error - Erreur serveur</li>
                        <li>503 : Service Unavailable - Service indisponible</li>
                    </ul>

                    <div class="schema-details">
                        <p><strong>Ã€ retenir :</strong></p>
                        <ul>
                            <li>1XX : Information (rarement utilisÃ©)</li>
                            <li>2XX : SuccÃ¨s</li>
                            <li>3XX : Redirection</li>
                            <li>4XX : Erreur client</li>
                            <li>5XX : Erreur serveur</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>


        <!-- Exercices -->
        <section id="exercices" class="section">
            <h2>Exercices Pratiques</h2>
            <div class="concept-card">
                <div class="exercise-container">
                    <!-- Exercice 1 -->
                    <div class="-card">
                        <h3>Exercice 1: CrÃ©ation d'une API REST</h3>
                        <div class="exercise-content">
                            <p class="exercise-description">
                                CrÃ©ez une API REST simple pour gÃ©rer une liste de livres avec les opÃ©rations
                                CRUD.
                            </p>
                            <div class="exercise-steps">
                                <h4>Ã‰tapes:</h4>
                                <ol>
                                    <li>CrÃ©er une classe Book (id, titre, auteur, annÃ©e)</li>
                                    <li>CrÃ©er un BookRepository</li>
                                    <li>ImplÃ©menter un BookController avec les endpoints CRUD</li>
                                    <li>Tester avec Postman ou cURL</li>
                                </ol>
                            </div>
                            <button class="solution-btn" data-exercise="1">Voir la solution</button>

                            <!-- Ajout de la solution -->
                            <div class="solution-content" id="solution-1">
                                <h4>Solution:</h4>

                                <div class="code-section">
                                    <h5>Book.java</h5>
                                    <pre><code>
@Entity
public class Book {
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;

private String title;
private String author;
private Integer year;

// Constructeurs, Getters et Setters
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookRepository.java</h5>
                                    <pre><code>
@Repository
public interface BookRepository extends JpaRepository<Book, Long> {
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookController.java</h5>
                                    <pre><code>
@RestController
@RequestMapping("/api/books")
public class BookController {

@Autowired
private BookRepository bookRepository;

// RÃ©cupÃ©rer tous les livres
@GetMapping
public List<Book> getAllBooks() {
return bookRepository.findAll();
}

// RÃ©cupÃ©rer un livre par ID
@GetMapping("/{id}")
public ResponseEntity<Book> getBookById(@PathVariable Long id) {
return bookRepository.findById(id)
    .map(ResponseEntity::ok)
    .orElse(ResponseEntity.notFound().build());
}

// CrÃ©er un nouveau livre
@PostMapping
public ResponseEntity<Book> createBook(@RequestBody Book book) {
Book savedBook = bookRepository.save(book);
return ResponseEntity.created(URI.create("/api/books/" + savedBook.getId()))
    .body(savedBook);
}

// Mettre Ã  jour un livre
@PutMapping("/{id}")
public ResponseEntity<Book> updateBook(@PathVariable Long id, @RequestBody Book book) {
return bookRepository.findById(id)
    .map(existingBook -> {
        book.setId(id);
        return ResponseEntity.ok(bookRepository.save(book));
    })
    .orElse(ResponseEntity.notFound().build());
}

// Supprimer un livre
@DeleteMapping("/{id}")
public ResponseEntity<Void> deleteBook(@PathVariable Long id) {
if (!bookRepository.existsById(id)) {
    return ResponseEntity.notFound().build();
}
bookRepository.deleteById(id);
return ResponseEntity.noContent().build();
}
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>Test avec cURL</h5>
                                    <pre><code>
# CrÃ©er un livre
curl -X POST http://localhost:8080/api/books \
-H "Content-Type: application/json" \
-d '{"title":"1984","author":"George Orwell","year":1949}'

# RÃ©cupÃ©rer tous les livres
curl http://localhost:8080/api/books

# RÃ©cupÃ©rer un livre par ID
curl http://localhost:8080/api/books/1

# Mettre Ã  jour un livre
curl -X PUT http://localhost:8080/api/books/1 \
-H "Content-Type: application/json" \
-d '{"title":"1984","author":"George Orwell","year":1948}'

# Supprimer un livre
curl -X DELETE http://localhost:8080/api/books/1
        </code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- Exercice 2 -->
                    <div class="-card">
                        <h3>Exercice 2: Validation des donnÃ©es</h3>
                        <div class="exercise-content">
                            <p class="exercise-description">
                                Ajoutez la validation des donnÃ©es Ã  votre API de livres.
                            </p>
                            <div class="exercise-steps">
                                <h4>Ã‰tapes:</h4>
                                <ol>
                                    <li>Ajouter les annotations de validation</li>
                                    <li>CrÃ©er un gestionnaire d'erreurs global</li>
                                    <li>Tester avec des donnÃ©es invalides</li>
                                </ol>
                            </div>
                            <button class="solution-btn" data-exercise="2">Voir la solution</button>
                            <!-- Solution Exercice 2 -->
                            <div class="solution-content" id="solution-2">
                                <h4>Solution:</h4>

                                <div class="code-section">
                                    <h5>Book.java (avec validations)</h5>
                                    <pre><code>
@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank(message = "Le titre est obligatoire")
    @Size(min = 1, max = 100, message = "Le titre doit faire entre 1 et 100 caractÃ¨res")
    private String title;
    
    @NotBlank(message = "L'auteur est obligatoire")
    @Size(min = 1, max = 50, message = "Le nom de l'auteur doit faire entre 1 et 50 caractÃ¨res")
    private String author;
    
    @NotNull(message = "L'annÃ©e est obligatoire")
    @Min(value = 1000, message = "L'annÃ©e doit Ãªtre supÃ©rieure Ã  1000")
    @Max(value = 9999, message = "L'annÃ©e doit Ãªtre infÃ©rieure Ã  9999")
    private Integer year;

    // Getters et Setters
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>ErrorResponse.java</h5>
                                    <pre><code>
public class ErrorResponse {
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private List<String> messages;

    public ErrorResponse(int status, String error, List<String> messages) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.error = error;
        this.messages = messages;
    }

    // Getters et Setters
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>GlobalExceptionHandler.java</h5>
                                    <pre><code>
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationErrors(MethodArgumentNotValidException ex) {
        List<String> errors = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.toList());

        ErrorResponse errorResponse = new ErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            "Erreur de validation",
            errors
        );

        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllUncaughtException(Exception ex) {
        ErrorResponse errorResponse = new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            "Erreur serveur",
            Collections.singletonList(ex.getMessage())
        );

        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookController.java (mise Ã  jour)</h5>
                                    <pre><code>
@RestController
@RequestMapping("/api/books")
public class BookController {
    
    @Autowired
    private BookRepository bookRepository;

    @PostMapping
    public ResponseEntity<Book> createBook(@Valid @RequestBody Book book) {
        Book savedBook = bookRepository.save(book);
        return ResponseEntity.created(URI.create("/api/books/" + savedBook.getId()))
            .body(savedBook);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Book> updateBook(
            @PathVariable Long id,
            @Valid @RequestBody Book book) {
        return bookRepository.findById(id)
            .map(existingBook -> {
                book.setId(id);
                return ResponseEntity.ok(bookRepository.save(book));
            })
            .orElse(ResponseEntity.notFound().build());
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>Test avec cURL (donnÃ©es invalides)</h5>
                                    <pre><code>
# Test avec un titre vide
curl -X POST http://localhost:8080/api/books \
     -H "Content-Type: application/json" \
     -d '{"title":"","author":"George Orwell","year":1949}'

# Test avec une annÃ©e invalide
curl -X POST http://localhost:8080/api/books \
     -H "Content-Type: application/json" \
     -d '{"title":"1984","author":"George Orwell","year":999}'

# RÃ©ponse d'erreur typique
{
    "timestamp": "2023-11-15T10:30:00",
    "status": 400,
    "error": "Erreur de validation",
    "messages": [
        "title: Le titre est obligatoire",
        "year: L'annÃ©e doit Ãªtre supÃ©rieure Ã  1000"
    ]
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>pom.xml (dÃ©pendances nÃ©cessaires)</h5>
                                    <pre><code>
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
    &lt;/dependency&gt;
    ...
&lt;/dependencies&gt;
        </code></pre>
                                </div>
                            </div>

                        </div>
                    </div>

                    <!-- Exercice 3 -->
                    <div class="-card">
                        <h3>Exercice 3: Tests unitaires</h3>
                        <div class="exercise-content">
                            <p class="exercise-description">
                                Ã‰crivez des tests unitaires pour votre API de livres.
                            </p>
                            <div class="exercise-steps">
                                <h4>Ã‰tapes:</h4>
                                <ol>
                                    <li>CrÃ©er des tests pour le Controller</li>
                                    <li>CrÃ©er des tests pour le Service</li>
                                    <li>Utiliser MockMvc pour les tests d'intÃ©gration</li>
                                </ol>
                            </div>
                            <button class="solution-btn" data-exercise="3">Voir la solution</button>
                            <!-- Solution Exercice 3 -->
                            <div class="solution-content" id="solution-3">
                                <h4>Solution:</h4>

                                <div class="code-section">
                                    <h5>BookService.java (ajout d'une couche service)</h5>
                                    <pre><code>
@Service
public class BookService {
    private final BookRepository bookRepository;

    @Autowired
    public BookService(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

    public List<Book> getAllBooks() {
        return bookRepository.findAll();
    }

    public Book getBookById(Long id) {
        return bookRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Livre non trouvÃ© avec l'id: " + id));
    }

    public Book createBook(Book book) {
        return bookRepository.save(book);
    }

    public Book updateBook(Long id, Book book) {
        getBookById(id); // VÃ©rifie si le livre existe
        book.setId(id);
        return bookRepository.save(book);
    }

    public void deleteBook(Long id) {
        getBookById(id); // VÃ©rifie si le livre existe
        bookRepository.deleteById(id);
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookServiceTest.java</h5>
                                    <pre><code>
@ExtendWith(MockitoExtension.class)
class BookServiceTest {
    @Mock
    private BookRepository bookRepository;

    @InjectMocks
    private BookService bookService;

    private Book testBook;

    @BeforeEach
    void setUp() {
        testBook = new Book();
        testBook.setId(1L);
        testBook.setTitle("Test Book");
        testBook.setAuthor("Test Author");
        testBook.setYear(2023);
    }

    @Test
    void getAllBooks_ShouldReturnListOfBooks() {
        // Arrange
        List<Book> books = Arrays.asList(testBook);
        when(bookRepository.findAll()).thenReturn(books);

        // Act
        List<Book> result = bookService.getAllBooks();

        // Assert
        assertEquals(1, result.size());
        verify(bookRepository).findAll();
    }

    @Test
    void getBookById_WithValidId_ShouldReturnBook() {
        when(bookRepository.findById(1L)).thenReturn(Optional.of(testBook));

        Book result = bookService.getBookById(1L);

        assertEquals(testBook.getTitle(), result.getTitle());
        verify(bookRepository).findById(1L);
    }

    @Test
    void getBookById_WithInvalidId_ShouldThrowException() {
        when(bookRepository.findById(1L)).thenReturn(Optional.empty());

        assertThrows(ResourceNotFoundException.class, () -> 
            bookService.getBookById(1L)
        );
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookControllerTest.java</h5>
                                    <pre><code>
@WebMvcTest(BookController.class)
class BookControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private BookService bookService;

    @Autowired
    private ObjectMapper objectMapper;

    private Book testBook;

    @BeforeEach
    void setUp() {
        testBook = new Book();
        testBook.setId(1L);
        testBook.setTitle("Test Book");
        testBook.setAuthor("Test Author");
        testBook.setYear(2023);
    }

    @Test
    void getAllBooks_ShouldReturnBooks() throws Exception {
        List<Book> books = Arrays.asList(testBook);
        when(bookService.getAllBooks()).thenReturn(books);

        mockMvc.perform(get("/api/books")
                .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].title").value("Test Book"))
                .andExpect(jsonPath("$[0].author").value("Test Author"));
    }

    @Test
    void createBook_WithValidData_ShouldReturnCreated() throws Exception {
        when(bookService.createBook(any(Book.class))).thenReturn(testBook);

        mockMvc.perform(post("/api/books")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(testBook)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.title").value("Test Book"));
    }

    @Test
    void createBook_WithInvalidData_ShouldReturnBadRequest() throws Exception {
        testBook.setTitle(""); // Invalid title

        mockMvc.perform(post("/api/books")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(testBook)))
                .andExpect(status().isBadRequest());
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookIntegrationTest.java</h5>
                                    <pre><code>
@SpringBootTest
@AutoConfigureMockMvc
class BookIntegrationTest {
    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private BookRepository bookRepository;

    @Autowired
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        bookRepository.deleteAll();
    }

    @Test
    void bookLifecycle() throws Exception {
        // Create
        Book newBook = new Book();
        newBook.setTitle("Integration Test Book");
        newBook.setAuthor("Test Author");
        newBook.setYear(2023);

        String createResponse = mockMvc.perform(post("/api/books")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(newBook)))
                .andExpect(status().isCreated())
                .andReturn().getResponse().getContentAsString();

        Book createdBook = objectMapper.readValue(createResponse, Book.class);

        // Read
        mockMvc.perform(get("/api/books/" + createdBook.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.title").value("Integration Test Book"));

        // Update
        createdBook.setTitle("Updated Title");
        mockMvc.perform(put("/api/books/" + createdBook.getId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(createdBook)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.title").value("Updated Title"));

        // Delete
        mockMvc.perform(delete("/api/books/" + createdBook.getId()))
                .andExpect(status().isNoContent());
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>pom.xml (dÃ©pendances de test)</h5>
                                    <pre><code>
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.h2database&lt;/groupId&gt;
        &lt;artifactId&gt;h2&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
        </code></pre>
                                </div>
                            </div>

                        </div>
                    </div>

                    <!-- Exercice 4 -->
                    <div class="-card">
                        <h3>Exercice 4: SÃ©curitÃ© avec Spring Security</h3>
                        <div class="exercise-content">
                            <p class="exercise-description">
                                SÃ©curisez votre API avec authentification basic.
                            </p>
                            <div class="exercise-steps">
                                <h4>Ã‰tapes:</h4>
                                <ol>
                                    <li>Configurer Spring Security</li>
                                    <li>CrÃ©er des rÃ´les utilisateur</li>
                                    <li>ProtÃ©ger les endpoints</li>
                                    <li>Tester l'authentification</li>
                                </ol>
                            </div>
                            <button class="solution-btn" data-exercise="4">Voir la solution</button>
                            <!-- Solution Exercice 4 -->
                            <div class="solution-content" id="solution-4">
                                <h4>Solution:</h4>

                                <div class="code-section">
                                    <h5>pom.xml (dÃ©pendances de sÃ©curitÃ©)</h5>
                                    <pre><code>
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>SecurityConfig.java</h5>
                                    <pre><code>
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeHttpRequests((auth) -> auth
                .requestMatchers(HttpMethod.GET, "/api/books/**").hasAnyRole("USER", "ADMIN")
                .requestMatchers(HttpMethod.POST, "/api/books").hasRole("ADMIN")
                .requestMatchers(HttpMethod.PUT, "/api/books/**").hasRole("ADMIN")
                .requestMatchers(HttpMethod.DELETE, "/api/books/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public InMemoryUserDetailsManager userDetailsService() {
        UserDetails user = User.builder()
            .username("user")
            .password(passwordEncoder().encode("userpass"))
            .roles("USER")
            .build();

        UserDetails admin = User.builder()
            .username("admin")
            .password(passwordEncoder().encode("adminpass"))
            .roles("ADMIN")
            .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>BookController.java (avec annotations de sÃ©curitÃ©)</h5>
                                    <pre><code>
@RestController
@RequestMapping("/api/books")
public class BookController {

    @PreAuthorize("hasAnyRole('USER', 'ADMIN')")
    @GetMapping
    public List<Book> getAllBooks() {
        // ...
    }

    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping
    public ResponseEntity<Book> createBook(@Valid @RequestBody Book book) {
        // ...
    }

    @PreAuthorize("hasRole('ADMIN')")
    @PutMapping("/{id}")
    public ResponseEntity<Book> updateBook(@PathVariable Long id, @Valid @RequestBody Book book) {
        // ...
    }

    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteBook(@PathVariable Long id) {
        // ...
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>Tests avec cURL</h5>
                                    <pre><code>
# Tentative sans authentification
curl http://localhost:8080/api/books

# Lecture avec utilisateur normal
curl -u user:userpass http://localhost:8080/api/books

# CrÃ©ation avec utilisateur normal (doit Ã©chouer)
curl -u user:userpass -X POST http://localhost:8080/api/books \
     -H "Content-Type: application/json" \
     -d '{"title":"1984","author":"George Orwell","year":1949}'

# CrÃ©ation avec admin (doit rÃ©ussir)
curl -u admin:adminpass -X POST http://localhost:8080/api/books \
     -H "Content-Type: application/json" \
     -d '{"title":"1984","author":"George Orwell","year":1949}'
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>SecurityTest.java</h5>
                                    <pre><code>
@SpringBootTest
@AutoConfigureMockMvc
class SecurityTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void getBooks_WithoutAuth_ShouldReturnUnauthorized() throws Exception {
        mockMvc.perform(get("/api/books"))
            .andExpect(status().isUnauthorized());
    }

    @Test
    void getBooks_WithUserRole_ShouldSucceed() throws Exception {
        mockMvc.perform(get("/api/books")
            .with(user("user").roles("USER")))
            .andExpect(status().isOk());
    }

    @Test
    void createBook_WithUserRole_ShouldBeForbidden() throws Exception {
        Book book = new Book();
        book.setTitle("Test");
        book.setAuthor("Author");
        book.setYear(2023);

        mockMvc.perform(post("/api/books")
            .with(user("user").roles("USER"))
            .contentType(MediaType.APPLICATION_JSON)
            .content(new ObjectMapper().writeValueAsString(book)))
            .andExpect(status().isForbidden());
    }

    @Test
    void createBook_WithAdminRole_ShouldSucceed() throws Exception {
        Book book = new Book();
        book.setTitle("Test");
        book.setAuthor("Author");
        book.setYear(2023);

        mockMvc.perform(post("/api/books")
            .with(user("admin").roles("ADMIN"))
            .contentType(MediaType.APPLICATION_JSON)
            .content(new ObjectMapper().writeValueAsString(book)))
            .andExpect(status().isCreated());
    }
}
        </code></pre>
                                </div>

                                <div class="code-section">
                                    <h5>application.properties (configuration optionnelle)</h5>
                                    <pre><code>
# DÃ©sactiver la page de login par dÃ©faut (pour API REST)
spring.security.basic.enabled=true
spring.security.user.name=user
spring.security.user.password=userpass

# Logs de sÃ©curitÃ© (utile pour le dÃ©veloppement)
logging.level.org.springframework.security=DEBUG
        </code></pre>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            </div>
        </section>


        <!-- Ressources -->
        <section id="ressources" class="section">
            <h2>Ressources Utiles</h2>
            <div class="resources-list">
                <a href="https://spring.io/projects/spring-boot" class="resource-link" target="_blank" rel="noopener">
                    <i class="fas fa-book"></i>
                    Documentation Officielle Spring Boot
                </a>
                <a href="https://start.spring.io/" class="resource-link" target="_blank" rel="noopener">
                    <i class="fas fa-play"></i>
                    Spring Initializr
                </a>
                <a href="https://github.com/spring-projects/spring-boot" class="resource-link" target="_blank"
                    rel="noopener">
                    <i class="fab fa-github"></i>
                    GitHub Spring Boot
                </a>
                <a href="https://spring.io/guides" class="resource-link" target="_blank" rel="noopener">
                    <i class="fas fa-graduation-cap"></i>
                    Spring Guides
                </a>
                <a href="https://satin-truffle-ac4.notion.site/1812ae802e2980f289aac0bb0c7378e4?v=0877a60633cc41188c1780036f37365e"
                    class="resource-link" target="_blank" rel="noopener">Spring boot - Index des notions
                    pour
                    dÃ©couvrir
                    Spring Boot Ã©tape par Ã©tape</a>
            </div>

            <div class="tips-section">
                <h3>Conseils et Bonnes Pratiques</h3>
                <ul>
                    <li>Utilisez les starters appropriÃ©s pour votre projet</li>
                    <li>Suivez la convention de nommage des packages</li>
                    <li>Utilisez la validation des donnÃ©es</li>
                    <li>ImplÃ©mentez des tests unitaires</li>
                    <li>Configurez correctement le logging</li>
                    <li>Utilisez les profiles Spring pour diffÃ©rents environnements</li>
                </ul>
            </div>
        </section>

        <!-- Modal -->
        <div id="modal" class="modal">
            <div class="modal-content">
                <span class="close">&times;</span>
                <div id="modal-text"></div>
            </div>
        </div>
        </>

        <!-- ScrollToTop -->
        <button id="scrollToTop" class="scroll-btn" title="Scroll to top">
            <i class="fas fa-arrow-up"></i>
        </button>

        <!-- ScrollToBottom -->
        <button id="scrollToBottom" class="scroll-btn" title="Scroll to bottom">
            <i class="fas fa-arrow-down"></i>
        </button>

        <script src="script.js"></script>
</body>

</html>